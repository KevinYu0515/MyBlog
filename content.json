{"posts":[{"title":"Commands List","text":"官網 git 文件 首次使用必要指令 設定使用者名稱 1git config --global user.name &quot;your_username&quot; 設定使用者電子信箱 1git config --global user.email &quot;your_email_address@example.com&quot; 列出使用者資訊 1git config --global --list 常見上傳流水線指令 初始化本地儲存庫 1git init 將檔案加入 git 暫存區 1git add . 將檔案提交至本地儲存庫 1git commit -m &quot;commit message&quot; 將檔案連結遠端儲存庫 1git remote add origin [repo_url] 將檔案上傳至遠端儲存庫 1git push -u origin main 分支指令、傳輸指令 查看分支列表（只有本地） 1git branch 查看分支列表（本地和遠端） 1git branch -a 創建新分支 1git branch [branch name] 刪除本地分支 1git branch -d [branch name] 刪除本地分支（強制執行） 1git branch -D [branch name] 刪除遠端分支 1git push origin --delete [branch name] 創建新分支並切換於此 1git checkout -b [branch name] 下載遠端分支並切換於此 1git checkout -b [branch name] origin/[branch name] 更名分支 1git branch -m [old branch name] [new branch name] 切換分支1git checkout branch [branch name] 切換回上個分支1git checkout - 捨棄該檔案的更動1git checkout -- [file-name.txt] 刪除該檔案1git rm -r [file-name.txt] 合併分支（合併於當前分支）1git merge [branch name] 合併分支（來源分支合併於目標分支）1git merge [source branch] [target branch] 預覽分支合併後的更動1git diff [source branch] [target branch] 上傳至遠端分支1git push [repo_url_shortname] [branch name] 上傳至遠端分支並且記憶該分支1git push -u [repo_url_shortname] [branch name] 上傳至遠端分支並且記憶該分支1git push 拉取遠端儲存庫更動1git pull 拉取遠端儲存庫更動1git pull [repo_url_shortname] [branch name] 增加遠端儲存庫 1git remote add [repo_url_shortname] [repo_url] 設置儲存庫的起點為 SSH1git remote set-url [repo_url_shortname] [repo_url] 移除遠端儲存庫1git remote remove [repo_url_shortname] 列出遠端儲存庫1git remote 列出遠端儲存庫(更詳細)1git remote -v 下載遠端儲存庫1git clone repo_url 下載遠端私人儲存庫1git clone [repo_url] 其他指令 查看當前狀態 1git status 將當前工作區加入暫存 1git stash 將暫存區清空 1git stash clear 列出歷史紀錄 1git log 列出詳細歷史紀錄 1git log --summary 列出簡要的歷史紀錄 1git log --oneline 還原提交更改 1git revert commitid 參考資料35+ Git Commands List Every Programmer Should Know","link":"/2022/09/26/Git%20Commands%20List/"},{"title":"Google Map 商家資料爬取","text":"技能大綱 如何用 Selenium 點擊、滑動、鎖定元素 如何用 Python 製作 json 相關 Library：selenium、pandas、json、bs4、time 主要過程與介紹 我打算製作 json 作為店家網站的評論資料庫，但 json 資料須定期更新，為了節省製作的時間，所以希望能透過自動化流程製作出近期評論的 json。 抓取過程（主要由 Selenium 操作） 第一部分：初始化設定 瀏覽器綁定：本次所使用的是 Edge 1browser = webdriver.Edge() 前往特定連結：如果有例外就取消視窗 12345url = &quot;https://reurl.cc/KQ0xNj&quot;try: browser.get(url)except: browser.execute_script(&quot;window.stop()&quot;) 超時設定：防止程式當機 12browser.set_page_load_timeout(10) # 頁面加載超過 10 秒就停止browser.set_script_timeout(10) # 設置此腳本停留超過 10 秒就停止 視窗放大 1browser.maximize_window() 第二部分：網頁操作與動態加載 評論篩選：透過 google map 提供的篩選功能將我們需要的評論先整理出來 點擊篩選功能按鈕 12345678# 等待瀏覽器跑出篩選功能的 classWebDriverWait(browser, 30).until(EC.presence_of_element_located((By.CLASS_NAME, 'S9kvJb')))# 鎖定我們需要的 class 作為我們的 WebElementcategory_click = browser.find_elements(By.CLASS_NAME,'S9kvJb')time.sleep(1)# 點擊篩選功能選項category_click[data_index].click()time.sleep(1) time.sleep()：由於點擊後要等到網頁更新畫面，所以我們設定時間等待一秒 點擊篩選選項按鈕 12345# 鎖定我們需要的篩選選項清單的 classcategory_click = browser.find_elements(By.CLASS_NAME,'fxNQSd')time.sleep(1)# 點擊我們需要的篩選選項category_click[sort_index].click() 動態加載：由於我們所需要的評論並不是一次加載完，而是根據我們移動頁面而持續的加載。 向下滑動頁面 1234time.sleep(1)# 透過 javascript 語法滑動頁面js = 'document.getElementsByClassName(&quot;m6QErb DxyBCb kA9KIf dS8AEf&quot;)[0].scrollTop=1000000'browser.execute_script(js) 讀取資料的網頁程式碼 12345time.sleep(3)# 使用 soup library 將目前網頁的程式碼取出soup = Soup(browser.page_source,&quot;lxml&quot;)# 鎖定所有評論的 classall_reviews = soup.find_all(class_ = 'jftiEf fontBodyMedium') 第三部分：尋找目標資料的網頁程式碼 抓取評論內容的各個資料並丟入陣列作儲存 123456789101112131415161718comments = [] # 全部評論的陣列i = -1 for ar in all_reviews:i += 1obj = [] # 暫存目前所抓的評論內容資料# 增加索引序號obj.append(i)# 增加評論者姓名obj.append(ar.find(class_ = &quot;d4r55&quot;).text)# 增加評論者給予的星星obj.append(str(ar.find(class_ = &quot;kvMYJc&quot;).get('aria-label').strip().strip(&quot; 顆星&quot;)))# 增加評論日期obj.append(ar.find(class_ = &quot;rsqaWe&quot;).text)# 增加評論內容obj.append(ar.find(class_ = &quot;wiI7pd&quot;).text)# 增加評論者頭像obj.append(ar.find(class_ = &quot;NBa7we&quot;).get('src'))comments.append(obj) # 存進全部評論的陣列 第四部分：打包成 json 送出 透過 panda 將資料整理成 json array 1select_df = pd.DataFrame(comments, columns = ['id','name','star','date','content','icon']) 載入 json array，製作成 json object 送出 123456# 載入 json arraydata = json.loads(select_df.to_json(orient = 'records'))# 製成 json objectj = {&quot;comments&quot;: data }with open('comment.json', 'w', encoding='UTF-8') as f: json.dump(j, f, ensure_ascii= False) 實作結果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import timeimport jsonimport pandas as pdfrom selenium import webdriverfrom bs4 import BeautifulSoup as Soupfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support import expected_conditions as ECif __name__ == '__main__': # 初始化 browser = webdriver.Edge() url = &quot;https://reurl.cc/KQ0xNj&quot; browser.set_page_load_timeout(10) browser.set_script_timeout(10) try: browser.get(url) except: browser.execute_script(&quot;window.stop()&quot;) browser.maximize_window() data_index = 4 sort_index = 2 # 點擊篩選選項功能 WebDriverWait(browser, 30).until(EC.presence_of_element_located((By.CLASS_NAME, 'S9kvJb'))) category_click = browser.find_elements(By.CLASS_NAME,'S9kvJb') time.sleep(1) category_click[data_index].click() time.sleep(1) # 點擊篩選樣式 category_click = browser.find_elements(By.CLASS_NAME,'fxNQSd') time.sleep(1) category_click[sort_index].click() # 滑動頁面加載更多資料 time.sleep(1) js = 'document.getElementsByClassName(&quot;m6QErb DxyBCb kA9KIf dS8AEf&quot;)[0].scrollTop=1000000' browser.execute_script(js) # 加載完成後，重新抓取資料 time.sleep(3) soup = Soup(browser.page_source,&quot;lxml&quot;) all_reviews = soup.find_all(class_ = 'jftiEf fontBodyMedium') # 找尋資料的網頁原始碼 comments = [] i = -1 for ar in all_reviews: i += 1 obj = [] obj.append(i) obj.append(ar.find(class_ = &quot;d4r55&quot;).text) obj.append(str(ar.find(class_ = &quot;kvMYJc&quot;).get('aria-label').strip().strip(&quot; 顆星&quot;))) obj.append(ar.find(class_ = &quot;rsqaWe&quot;).text) obj.append(ar.find(class_ = &quot;wiI7pd&quot;).text) obj.append(ar.find(class_ = &quot;NBa7we&quot;).get('src')) comments.append(obj) # json 打包 select_df = pd.DataFrame(comments, columns = ['id','name','star','date','content','icon']) data = json.loads(select_df.to_json(orient = 'records')) j = {&quot;comments&quot;: data } with open('comment.json', 'w', encoding='UTF-8') as f: json.dump(j, f, ensure_ascii= False) 資料來源 Medium Google Map Review 動態爬蟲：如何獲取店家評論內容、圖片以及篩選評論（附Python程式碼） Medium Google Map Review 動態爬蟲：如何解決評論動態加載的問題以及在不同視窗間跳轉、滑動（附Python程式碼） CSDN 頁面滑動 CSDN 內嵌 div 滾動","link":"/2022/08/20/Google%20Map%20%E5%95%86%E5%AE%B6%E8%B3%87%E6%96%99%E7%88%AC%E5%8F%96/"},{"title":"Forensics Beginner","text":"工具列表資訊提取 strings：Linux 系統的原生命令列工具，可以用來將二進位檔案的可閱讀部分取出 exiftool：用於讀寫、檢視圖片、音訊、PDF等檔案格式的 metadata binwalk：用於分析二進位檔案的工具，可提取出嵌入的檔案系統、壓縮資料、暗藏的程式碼，此外還提供數位簽名檢查、自定義模式匹配特定內容等功能 pngcheck：可用於檢查每個 chunk（數據塊）是否符合 PNG 格式，為修復 PNG 的一大利器 隱寫 steghide：可以用來處理圖片和音頻的隱寫工具 zsteg：用於檢測 PNG、BMP 圖片格式的隱寫數據，主要支援以下隱寫類型 LSB steganography in PNG &amp; BMP zlib-compressed data OpenStego Camouflage 1.2.1 LSB with The Eratosthenes set StegSolve：基於 Java 開發的圖片隱寫檢視器，也支援多種圖片格式，可以查看圖片的具體資訊、提取檔案的 RGB 資訊、進行立體試圖分析、瀏覽動圖的幀資訊以及進行圖片拼接等操作 位元處理 xxd：Linux 系統的原生命令列工具，可用於將檔案轉換為十六進位、二進位的表示方式並對位元編輯，也能將編輯後檔案進行反轉 VsCode hex editor plugin：VsCode 編輯器的插件，可將檔案以十六進位方式表示 bytes，並對此進行編輯（習慣用 GUI 很推這個編輯器） 封包分析 WireShark：網路封包分析軟體，可以用來截取網路封包，顯示網路封包資料 磁碟分析 sleuthkit：電子取證調查工具，可以使用 CLI 的方式於磁碟恢復丟失的文件、並對磁碟進行映像分析 autopsy：sleuthkit 的網頁接口，基本上支援 sleuthkit 的所有功能，以 GUI 方式進行 實用網站 CyberChef：一個圖形化介面的網站，提供加解密、加解碼、資料格式轉換、哈希計算、文本處理、網絡流量分析的超級瑞士刀 decodeUnicode.org：一個網站記載 unicode 的編碼，包含 UTF-8、UTF-16 等表示方式 重要知識常見檔案格式圖片格式被程式讀取時，通常都是倒過來讀取的，所以將 bytes 轉換回 decimal 需要倒著計算，如下： 00 04 00 00 的 4 個 bytes，應該要被解讀成 0x400(0x00000400)，也就是 1024 bytes注意不要算成 0x40000，這樣數字會超大 png formatPNG 圖像格式由一個 8 bytes 的檔案辨識標頭 + 3 個以上的資料塊（chunk）組成，即 file header + 3 chunks File Header：89 50 4E 47 0D 0A 1A 0A hex bytesCode description 89 檢測傳輸系統是否支援 8 位元的字元編碼，減少將文字檔案被錯誤的辨識成 PNG 檔案的機會。 50 4E 47 分別對應 PNG 的 ASCII，讓使用者方便辨識。 0D 0A DOS 風格的換行符，也就是所謂的 CRLF。用於 DOS-Unix 資料的換行符轉換。 1A 在 DOS 命令列下，用於阻止檔案顯示的檔案結束符。 0A Unix 風格的換行符（LF）。用於 Unix-DOS 換行符的轉換。 Chunk：又可分為關鍵資料塊和輔助資料塊，每個資料塊的組成如下 name bytes count description Length 4 bytes 指定資料塊中資料區域的長度，長度不可超過(2^31-1)個位元組 Chunk Type Code 4 bytes 由 ASCII 字母(A-Z和a-z) 組成 Chunk Data 可變長度 儲存指定的數據 CRC 4 bytes 儲存用來檢測是否檔案傳輸有誤的循環冗餘碼 關鍵資料塊（critical chunk）: IHDR（header chunk）：包含圖像基本資訊，作為第一個資料塊出現並只出現一次。 PLTE（palette chunk）：必須放在 IDAT 之前。 IDAT（image data chunk）：儲存實際圖像資料。PNG 資料允許包含多個連續的 IDAT。 IEND（image trailer chunk）：放在檔案尾部，表示 PNG 資料流結束。 輔助資料塊（ancillary chunks）： Chunk Type Code description position limit cHRM 基色和白色點資料塊 放在 PLTE 和 IDAT 之前 gAMA 圖像 γ 資料塊 放在 PLTE 和 IDAT 之前 sBIT 樣本有效位資料塊 放在 PLTE 和 IDAT 之前 bKGD 背景顏色資料塊 放在 PLTE 之後 IDAT 之前 hIST 圖像直方圖資料塊 放在 PLTE 之後 IDAT 之前 tRNS 圖像透明資料塊 放在 PLTE 之後 IDAT 之前 pHYs 物理像素尺寸資料塊 放在 IDAT 之前 tIME 圖像最後修改時間資料塊 無限制 tEXt 檔案基本訊息資料塊 無限制 zTXt 壓縮文字資料塊 無限制 eXIf 可交換圖像文件格式 (Exif) 資料塊 放在 IHDR 和 IEND 之間，但不能在 IDAT 之間 sCAL (專用公共數據塊) 放在 IDAT 之前 oFFs (專用公共數據塊) 放在 IDAT 之前 fRAc (專用公共數據塊) 無限制 gIFg (專用公共數據塊) 無限制 gIFt (專用公共數據塊) 無限制 gIFx (專用公共數據塊) 無限制 bmp formatBMP 格式由 File Header + Info Header + (optional palette) + Raw Data 組成不過通常 optional palette 不會出現，所以也可以將其省略 File Header：用於辨識 BMP 格式，總共佔 14 bytes，組成如下 name bytes count description type 2 bytes 剛好對應 BM 的 ASCII，也就是 0x42、0x4D size 4 bytes 紀錄 BMP 檔案的大小 reserved 1 2 bytes 保留欄位 reserved 2 2 bytes 保留欄位 offset 4 bytes 具體圖片資料離檔案開頭的偏移量 Info Header：BMP 圖片的 meta data，組成如下 name bytes count description size 4 bytes 表示 Info Header 的長度 width 4 bytes 圖檔寬度為多少 pixel height 4 bytes 圖檔高度為多少 pixel planes 2 bytes 位元圖層數 bits 2 bytes 每個 pixel 需要多少 bits compression 4 bytes 0，代表不壓縮；1，代表壓縮 imagesize 4 bytes 點陣圖的資料大小 xresolution 4 bytes 水平解析度 yresolution 4 bytes 垂直解析度 ncolours 4 bytes 點陣圖使用的調色盤顏色數 importantcolours 4 bytes 重要的顏色數 Raw Data：剩下的就是點陣圖的檔案資料，需要注意幾點 按照 info header 的 bits 決定每幾個 bytes 一組。如 bits 為 0x20，就代表每四個 bytes 一組 若圖片的長寬都是 16 pixels，就代表圖片的每一列需要 16 x 4 = 64 bytes，整張圖需要 64 * 16 = 1024 bytes，而這也就是 Raw Data 的長度 zip formatZip 格式由 Local file header + Central directory file header + End of central directory record 組成 Local file header signature：主要查看是否有 PK 標頭，即 0x04034b50Central directory file header signature： 0x02014b50End of central directory signature： 0x06054b50 除了這些標頭，其他每個 bytes 也都有特別意義，但在打 picoCTF 時沒有使用到，就暫先不提 一些特別的 Protocol TFTP：為 TCP/IP 協定中一種簡單的檔案傳輸協定，基於 UDP 協定傳送檔案，只能從檔案伺服器下載或上傳檔案，並不能列出目錄 UPnP：一種通訊協定，提供家中的設備可以輕易的自動連結到網路並完成相關設定。也就是說如果作業系統有開啟這項協定，就會自動新增設備於電腦上 SSDP：在 UPnP 的環境中，提供了一個網路用戶端可以用來發現網路服務的機制，使用 1900 Port ARP（位址解析協定）：一種網路協議，用於將 IP 位址對應到 MAC 位址 DNS：一套用於將容易記憶的域名轉換為對應的 IP 地址的系統 題目紀錄Simple Recon遇到未知的檔案可以先用以下工具、命令先蒐集資訊 file [file name]：確認檔案類型 拿 zsteg（只有 PNG、BMP 才有用）、binwalk、exiftool 解析檔案 如果是圖片嘗試把圖片打開 =&gt; 檔案修復、找線上工具 打開 hex Editor 看 hex bytes 或 strings 抓取可閱讀部分 資訊蒐集完，進一步猜測要做隱寫解析、隱藏檔案提取、檔案修復處理等經典題目操作 以上都沒有的話就可以開始通靈了 如果很明確的是 pcap、pcapng 這種網路封包的檔案，那就是開 wireshark 去解析，以下為常見操作 Dump files String search Follow tcp or udp IO Graphs Statistic Analyize Extract Protocol File 如果是 disk img ，那就是要作磁碟映像分析，通常用到 Sleuthkit（CLI）、Autopsy（GUI）分析常見的 SleuthKit 命令： mmls：將磁碟的每一層資訊列出 fls：將磁碟檔案列出，通常會搭配偏移量 -o icat：抓取磁碟檔案的內容，通常會搭配偏移量 -o Generalinformation照著 Simple Recon 走一遍，可以發現在 exiftool 解析時發現奇怪的資訊把這兩段亂碼拿去 base64 decode 看看 12echo &quot;7a78f3d9cfb1ce42ab5a3aa30573d617&quot; | bas64 -decho &quot;cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9&quot; | base64 -d Matryoshka doll發現在 binwalk 解析時，有隱藏的圖片，也就是圖中圖 Zip archive data, at least v2.0 to extract, compressed size: 378952, uncompressed size: 383937, name: base_images/2_c.jpg 所以把圖片擷取出來吧，節取出來的資料夾會以 _extract 開頭 1binwalk -e dolls.jpg 然後照著做下去到第四層時，就會找到 FLAG 了，套的真深 Format Restoretunn3l v1s10n先用 exiftool 解析，在 File Type 資訊可以知道這是一張 BMP 接著打開 Hex Editor，查看 Hex Bytes 有沒有錯誤才會導致程式解析失敗 File Header type：符合 42、4D =&gt; 不用修改 size：8E 26 2C 00，表示 0x2C268E（2893454 bytes），也符合資訊 =&gt; 不用修改 reserved：00 00 00 00，兩個保留區 =&gt; 不用修改 offset：偏移量不符合 =&gt; BA D0 00 00 應該要設置為 36 00 00 00 Info Header size：長度不符合 =&gt; BA D0 00 00 應該要設置為 28 00 00 00 接著要計算圖片大小是不是 2893454 bytes 圖片的寬：6E 04 00 00 =&gt; 0x46E（1134 pixels） 圖片的高：32 01 00 00 =&gt; 0x132（306 pixels） 圖層數：01 00 =&gt; 0x1（1 層） 每個 pixels 需要多少 bits：18 00 =&gt; 0x18（24 bits） 計算結果：1134 x 306 x 1 x 24 / 8 = 1041012 bytes =&gt; 不符合，所以要通靈修改哪一個資訊修改過程：2893454 * 8 / 24 / 1134 = 850.5（0x352） =&gt; 將圖片的高改成 52 03 00 00 最後將副檔名改成 .bmp 就可以把圖片解析出來了 c0rrupt先用 exiftool 解析檔案，但很可惜推測不出檔案類型 那就直接打開 Hex Editor 通靈檔案格式，可以看到以 89 開頭，又有 N 的 ASCII，此外又出現 pHYs 的 chunk name，所以應該是 PNG。 那就開始修復 PNG 吧，這邊可以搭配 pngcheck，會幫助我們偵測這張 PNG 哪裡有錯 File Header 修復：89 50 4E 47 0D 0A 1A 0A Chunks 修復 pngcheck 提示 1： 修復 IHDRpngcheck 提示 2： 修復 pHYS 的 CRC 部分pngcheck 提示 3： 修復無效的 chunk 長度，將 AA AA FF A5 改成 00 00 FF A5pngcheck 提示 4： 修復 IDAT 這樣就完成 PNG 修復了 Flow Analyizeshark on wire 1用 wireshark 打開檔案後，快速翻閱一下 Protocol，可以看到很多 UDP，猜測 FLAG 應該藏在 UDP 內 可以點擊中間畫面的 Protocol Column，就會以 Protocol Name 的方式排序，這樣就能把相同的 Protocol 聚集起來 要檢視 udp Protocol，可以對想要檢視的 Protocol 點右鍵後就會有一個 Follow &gt; UDP Stream 的功能，這樣就能去分析這份 protocol stream 的內容，要切換 stream 只要點擊右下角 翻著翻著就會找到 FLAG 了，可以知道是在 udp stream 6 Eavesdrop打開 wireshark 查看 pcap，從 tcp stream 0 可以看出以下的聊天紀錄 從聊天紀錄可以知道用 openssl 來解碼，所以我們還需要在找到被加碼的檔案，在 packet 61，發現這一個被加鹽過的檔案內容，所以我們可以合理懷疑就是這份檔案 所以把這個檔案抓出來，可以使用 pyshark 來抓取，或者將內容以 Hex Bytes 的方式呈現再手動填入。以下為參考腳本 12345678910111213141516171819import subprocessdata = b&quot;\\x53\\x61\\x6c\\x74\\x65\\x64\\x5f\\x5f\\x3c\\x4b\\x26\\xe8\\xb8\\xf9\\x1e\\x2c\\x4a\\xf8\\x03\\x1c\\xfa\\xf5\\xf8\\xf1\\x6f\\xd4\\x0c\\x25\\xd4\\x03\\x14\\xe6\\x49\\x7b\\x39\\x37\\x58\\x08\\xab\\xa1\\x86\\xf4\\x8d\\xa4\\x2e\\xef\\xa8\\x95&quot;with open (&quot;file.des3&quot;, &quot;wb&quot;) as f: f.write(data)openssl_cmd = [ 'openssl', 'des3', '-d', '-salt', '-in', 'file.des3', '-out', 'file.txt', '-k', 'supersecretpassword123']subprocess.run(openssl_cmd, check=True)with open('file.txt', 'r') as f: print(f.read()) Disk AnalyizeSleuthkit Apprentice這一題要用 Sleuthkit 的命令列工具來對磁碟映像解析，按照 Simple Reconn 實作一遍先用 mmls 把磁碟的每一層資訊列出來 1mmls disk.flag.img 接著用 fls 列出資料夾，這裡要搭配 -o 參數，可以看到第一個 Linux 的開始位元組是在 2048，所以先把他列出來 1fls -o 2048 disk.flag.img 可以看到這些資料夾沒有熟悉的部分，所以繼續往下找 1fls -o 360448 disk.flag.img 可以看到有一個 root 資料夾，所以繼續往下找 1fls -o 360448 disk.flag.img 1995 可以看到裡面有個 my_folder 資料夾，繼續往下找 1fls -o 360448 disk.flag.img 3981 接著將 flag.uni.txt 抓取內容出來 1icat -o 360448 disk.flag.img 2371 d/d：是資料夾r/r：是檔案，有些檔案會標註 realloc，代表以前有配置這份檔案 至於其他 picoCTF 的題目，另作一份筆記詳閱 參考資料 Sleuthkit TSK Tool zip format bmp format png format","link":"/2024/05/06/Forensics%20%E5%88%9D%E5%AD%B8%E8%80%85%E7%B4%80%E9%8C%84/"},{"title":"Migrate from SQLite DB to PostgreSQL DB in Grist","text":"新增環境變數要改變 Grist 的資料庫類型非常簡單，甚至連程式都不需要寫，首先需要新增以下環境變數 TYPEORM_DATABASE: [your_datbase_name] TYPEORM_USERNAME: [your_username] TYPEORM_PASSWORD: [your_password] TYPEORM_PORT: [your_port] TYPEORM_TYPE: postgres 可以將環境變數加入 /etc/profile，這樣就不用每次都手動新增 /etc/profile12345export TYPEORM_DATABASE=[your_datbase_name]export TYPEORM_USERNAME=[your_username]export TYPEORM_PASSWORD=[your_password]export TYPEORM_PORT=[your_port]export TYPEORM_TYPE=postgres 接著 source /etc/profile，就可以執行該 bash shell，此時我們呼叫 env | grep &quot;TYPE&quot;，就可以確認是否有加入環境變數 安裝 PostgreSQLGrist 需要的變數設好後，就需要給一個資料庫給 Grist 連接，這邊使用 Local Databse，但從 Docker 下載使用 12docker pull postgresdocker run --name postgres -e POSTGRES_PASSWORD=[your_password] -p 5432:5432 -d postgres 裝好 postgres 之後，可以再額外安裝 postgres-client 用 CLI 來嘗試連接 local database 12sudo apt install postgres-clientpsql -U [username] -h localhost -p 5432 -d [your_database_name] 但如果我不知道 username 和 database_name，可以先進入 docker 內的 postgres 查看，不過預設 username 通常會是 postgres，所以先嘗試用預設登入試試 1docker exec -it [your-container-id] psql -U postgres 進入 postgres shell 之後，可以使用以下指令去找出基本資訊 123\\list # 列出基本資訊select current_username; # 查出現在使用者select current_database(); # 查出現在資料庫 使用 pgloader 轉換 database file type在 Ubuntu 上，可以直接使用 pgloader 來轉換 sqlite 的 database fie 為 postgres 的 database file 1sudo apt install pgloader 安裝好後新增一個 db.load，並加入以下內容 12345load database from sqlite:///PATH/TO/LANDING.DB into postgresql://DB_USER:DB_PASSWORD@DB_HOST/DB_NAMEwith truncate, data only; 最後直接跑 pgloader 指令就可以了，基本上這樣就轉換成功了 1pgloader db.load 相關資料 pgloader github how-to-migrate-from-a-sqlite-db-to-postgresql","link":"/2025/02/18/Migrate-from-SQLite-DB-to-PostgreSQL-DB-in-Grist/"},{"title":"Node.js Event Loop VS. Browser Event Loop","text":"同步與非同步同步的意思是一次只處理一次事件，而非同步的意思是同時多個事件一起處理。如下 同步執行同步執行就是將程式碼一行一行執行下來 123console.log(&quot;Beginning&quot;)console.log(&quot;Hello World&quot;)console.log(&quot;Ending&quot;) 執行結果：BeginningHello WorldEnding 非同步執行非同步執行就是同時執行多個程式碼，而 setTimeout 就是個非同步執行的程式碼，我們稱之為非同步事件，你可以發現輸出結果，竟然是先打印出 End，再打印出 Hello World。直觀的想不是應該要等待 0 秒後就直接打印出來嗎？這個問題於之後會解答 12345console.log(&quot;Beginning&quot;)setTimeout(() =&gt; { console.log(&quot;Hello World&quot;)}, 0)console.log(&quot;Ending&quot;) 執行結果：BeginningEndingHello World 了解甚麼是同步與非同步之後，其實有一個 Bug 就是 JavaScript 是單執行續的程式，她沒有其他的執行緒能使用啊，到底是如何做到非同步的效果。這就與 JavaScript 的環境和 JavaScipt 的事件佇列有關，而這樣對事件處理的過程就稱為 Event Loop。接下來將會對 JavaScript 在瀏覽器環境下的 Event Loop 和 Node.js 環境下的 Event Loop 去做講解。 JavaScipt 在 Browser 上使用在 Browser 環境下，遇到非同步事件的處理過程如下： 名詞介紹Call StackCall Stack 的角色就是執行緒，將要被執行的程式放入 Call Stack，接著在由上往下執行 同步事件立刻執行 非同步事件放到 Callback Queue 等待下一次執行 Web ApisWeb Apis 的角色就是補充包，若在 Call Stack 中出現 Web Apis 可支援的方法，如：setTimeout，則從 Web Apis 取出放入 Callback Queue 等待下一次執行 Callback QueueCallback Queue 的角色就是事件佇列，所有非同步事件會先被放入這裡，等待 Call Stack 清空後，再將裡面的所有程式放入 Call Stack 流程說明Demo 1說明：非同步呼叫 web apis 的流程 123456789const A = () =&gt; console.log(&quot;Beginning&quot;)const B = () =&gt; console.log(&quot;Ending&quot;)const C = () =&gt; console.log(&quot;Function C&quot;)const D = () =&gt; console.log(&quot;Function D&quot;)console.log(&quot;Beginning&quot;)setTimeout(() =&gt; D(), 300)setTimeout(() =&gt; C(), 100)console.log(&quot;Ending&quot;) 執行結果：BeginningEndingFunction CFunction D 圖解說明： Function A 是同步事件，所以直接執行 setTimeout 是非同步事件，呼叫 web Apis Function B 是同步事件，所以直接執行 setTimout 先完成的先放入 Callback queue，所以是 Function C 和 Function D Call Stack 清空後，將 Function C、Function D 放入 Function C 和 Function D 都是同步事件，所以依序執行 Callback Queue 清空，程式結束 Demo 2說明：同時使用 Promsie 與 web apis 的執行順序 123456789101112131415const A = () =&gt; console.log(&quot;Beginning&quot;)const B = () =&gt; console.log(&quot;Ending&quot;)const C = () =&gt; console.log(&quot;Function C&quot;)const D = () =&gt; console.log(&quot;Function D&quot;)const E = () =&gt; console.log(&quot;Function E&quot;)console.log(&quot;Beginning&quot;)setTimeout(() =&gt; C(), 0)new Promise(function(resolve, reject) { D() resolve('resolve')}).then(result =&gt; { E()})console.log(&quot;Ending&quot;) 執行結果：BeginningFunction DEndingFunction EFunction C Function A 是同步事件，所以直接執行 setTimeout 是非同步事件，呼叫 web Apis Promise 是同步事件，所以直接執行 但是 Promise 的 resolve 和 recject 結果則是非同步事件，所以放入 Callback queue setTimout 放入 Callback queue Call Stack 清空後，將 Function E、Function C 放入 Function E 和 Function C 都是同步事件，所以依序執行 Callback Queue 清空，程式結束 JavaScript 在 Node.js 上使用JavaScript 在 Node.js 環境下，和 Browser 環境不同的是，沒有 web apis 可以呼叫，但可以呼叫 node.js 的內建方法，此外還加入了 I/O 操作和 process object 的概念，所以使得非同步事件的處理更為複雜。不過基本上 Event Loop 沒有太大變化，只是多了非同步事件的優先順序要判斷而已，接下來要介紹非同步事件種類的處理順序 名詞介紹nextTick Queue此 queue 的優先級別最高process.nextTick() 的 callback function 都會來這裡 microTask Queue此 queue 的優先級別第二高resolve 或 reject 所執行的 callback function 會被排在這裡 macroTask Queue當上面兩種 queue 都清空時，才會開始跑這些事件 timers：處理計時器相關的事件，例如 setTimeout 和 setInterval 設定的事件 pending callbacks：處理一些系統級別的回調 idle、prepare：node.js 內部使用 poll：查詢 I/O 操作的事件，例如讀取文件，網路請求等 check：處理 setImmediate() 設定的事件 close callbacks：處理一些關閉事件的回調 流程說明Demo 1說明：多種非同步事件執行順序 123456789101112131415161718192021222324252627282930console.log(&quot;Beginning&quot;) process.nextTick(function() { console.log('nextTick1');}); setTimeout(function() { console.log('setTimeout');}, 0); new Promise(function(resolve, reject) { console.log('promise'); resolve('resolve');}).then(function(result) { console.log('promise then');})(async function() { console.log('async');})(); setImmediate(function() { console.log('setImmediate');}); process.nextTick(function() { console.log('nextTick2');}); console.log('Ending'); 執行結果：BeginningpromiseasyncEndingnextTick1nextTick2promise thensetTimeoutsetImmediate Beginning 是同步事件，直接執行 nextTick1 代表下一次的執行序，所以放到 nextTick Queue setTimeout 是非同步事件，放到 macroTask Queue Promise 是同步事件，所以直接執行 但是 Promise 的 resolve 結果要放到 microTask Queue async 是同步事件，直接執行 setImmediate 是非同步事件，放到 macroTask Queue nextTick2 代表下一次的執行序，所以放到 nextTick Queue Ending 是同步事件，直接執行 從 nextTick Queue 開始取出放入 call Stack，接著反覆執行直到 nextTick Queue 是空的 從 microTask Queue 開始取出放入 call Stack，接著反覆執行直到 microTask Queue 是空的 若 nextTick Queue 和 micro Task Queue 都清空後，才從 macroTask Queue 開始取出放入 call Stack 反覆執行直到所有 Queue 和 Stack 清空為止 Demo 2說明：當非同步事件中又有其他非同步事件時的執行順序 123456789101112131415161718192021222324console.log(&quot;Beginning&quot;) process.nextTick(function() { console.log(&quot;nextTick1&quot;) process.nextTick(() =&gt; { console.log(&quot;nextTick2&quot;) })});setTimeout(function() { new Promise(function(resolve, reject) { console.log('promise'); resolve('resolve'); }).then(result =&gt; { process.nextTick(() =&gt; { console.log(&quot;nextTick3&quot;) }) }).then(result =&gt; { console.log('promise then'); }) console.log('setTimeout');}, 0);console.log('Ending'); 執行結果：BeginningEndingnextTick1nextTick2promisesetTimeoutpromise thennextTick3 Beginning 是同步事件，直接執行 nextTick1 代表下一次的執行序，所以放到 nextTick Queue setTimeout 是非同步事件，放到 macroTask Queue Ending 是同步事件，直接執行 從 nextTick Queue 取出，nextTick1 執行，遇到 nextTick2 放入 nextTick Queue 從 nextTick Queue 取出，nextTick2 執行 由於 nextTick Queue 和 microTask Queue 都是空的，所以從 macroTask Queue 取出 setTimeout 執行，遇到 Promise 先執行，因為 Promise 創建時是同步事件，接著將 resolve 放入 microTask Queue setTimout 繼續執行打印出 setTimout 從 microTask Queue 取出，先遇到 nextTick3 放入 nextTick Queue，繼續執行打印出 promise then 從 nextTick Queue 取出 nextTick3 執行 所有的 stack 和 queue 都清空，程式結束 總結JavaScript 是藉由 call Stack (單執行緒) 和 callback Queue (事件佇列) 實現多執行緒的效果。在 Browser 中，非同步事件主要與 web 有關，所以會需要經常從 web Apis 呼叫所需要的方法。而 Node.js 中，非同步事件的種類更為複雜，所以設計了 nextTick Queue、microTask Queue 和 macroTask Queue 等 callback Queue 的設計來分類處裡，所以只要弄清楚現在的非同步事件是甚麼類型，就可以搞懂那些奇怪的輸出結果。 但仔細想想非同步事件只是重新安排程式的處理順序而已，並沒有比較快。沒錯，只是被重新安排的程式不會是非同步事件本身，而是非同步事件內的其他程式，如下： 1setTimeout(() =&gt; console.log(&quot;Hello&quot;), 2000) 當我們遇到了 setTimeout 這個非同步事件，我們會讓他開始計時兩秒，接著跳過繼續執行下一個程式。當計時結束時，才會把 console 放入事件佇列，所以被重新安排的其實是 console 這個程式，而不是把 setTimeout 整個放到最後執行 簡單來說就是讓這個非同步程式先開始執行，如連結資料庫，抓取 api，計時等，當程式執行完的結果就放到事件佇列等待。因此在處理較耗時的程式時，就不容易造成程式堵塞，建議在較大型、複雜的應用上，能採用非同步事件的設計來加速程式運作的過程。 資料來源 完全圖解 Node.js Event Loop JavaScript Event Loop","link":"/2023/08/01/Node.js%20Event%20Loop%20VS.%20Browser%20Event%20Loop/"},{"title":"HCCCON &amp; 2023 FCU 資安週感想","text":"本文概要今天不談技術，主要寫個人感受，因此這篇文章是紀錄我這一年在黑客社參加資安週、研討會活動的心路歷程，但其實我在資安週的工作量遠大於研討會活動的雜事? 也就如此，會以準備資安週的過程，遇到的困難為主，而於最後簡單提一下擔任研討會工作人員的感受。 資安週這一年的資安週 Lab，我負責 OAuth Lab 和 Dos Lab，向大眾展示授權方面的資安風險以及 Dos 的攻擊手法。 OAuth Lab這個 Lab 主要宣導如果隨意授權應用程式，將有可能提高個資外洩的風險，所以我們採用聊天機器人這個常見的授權應用程式作為開端，並選擇了 discord 和 line 作為研究對象。 discord不過於 discord 的部分一開始其實並沒有打算真的架一台 discord bot，而是希望能透過以 OAuth2 形式的 discord application 要求 scopes 的 messages.read 權限經由 RPC 抓取訊息，但結果是呼叫不到 RPC 的 API，因此抓取不到訊息 接著我創建了 discord bot 並透過 gateway API，來抓取機器人所待的伺服器所有訊息，而這個部分效果不錯，問題點在於社交工程，因為要將機器人加進伺服器的過程並非一步即可，容易起疑，導致這個 Lab 的展示宣傳效果有限 line於 line 的部分，一開始打算使用 line bot 做到訊息監聽的效果，但是這個前提是需要將 line bot 加入的群組中，而這點較不常出現在日常生活的使用，所以後來轉向 LIFF 的釣魚連結設計，向使用者要求發送訊息的權限來做點惡作劇，剛好 LIFF 的完整應用有學長寫好的，因此我的工作變成如何有效地展示 LIFF 的授權。最後我將其與 Line bot 結合，當加入 Line bot 為好友時，會自動發出 LIFF 的連結，並且也把 LIFF 的製作工具連結一同送出，這樣除了成功宣導授權的資安風險，也與使用者能有更多的互動性。 OAuth 小結雖然在 discord 的開發上四處碰壁，讓我常常懷疑是否沒有漏洞可以利用的可能性，但經過這一次的開發，讓我對 discord application 有更多的了解，希望當我能力更好的時候再來看看 RPC API 時，能找出卡住的原因 而 Line 的開發上較為順利，感謝學長給的 LIFF 大禮包，讓我只需要簡單的寫寫 TS 和部屬到 netlify 上就可以了，另外也讓這個 lab 重新活了起來，有空的時候可以再把剩下的 LIFF documentation 看完，了解一下學長怎麼做的，但好像要先學會 React，這坑有點大啊… Dos LabDos Lab 的部分負責將網路流量轉化成動態折線圖，對我而言，較新奇的點是要在虛擬機上寫程式，當然也是最痛苦的部分，而這個部分可以分成兩個階段來講。 第一個階段是接手 Dos 之前，我打算先把製圖程式寫好，所以選了當時我比較擅長的 js，採用 d3.js 套件，先用 pyshark 抓取流量後同步傳送給 js 繪製。但結果沒想到同時兩台虛擬機互打很吃硬體性能，導致我的電腦常常還沒執行其中一台虛擬機上的 dos 程式，另一臺就死掉了，因此我們希望能減少檢查點，也就是架設 dos 的步驟越簡單越好，因此這樣還要跨語言的過程就必須簡化，所以只好捨棄花了我一週研究的 d3.js，換成同樣是 python 的 matplotlib 套件來繪製 而第二個階段為 Dos 的程式、被攻擊的伺服器以及製圖程式都完成之後的測試階段，這個部分遇到的問題是 pyshark 抓取流量與 matplotlib 兩個不同的 process 交互之間的延遲，理論上約為 2 秒鐘，但實際情況完全不一樣，所以在調整流量的閥值、抓取時間的這個部分上花了很久、其中經歷了一波硬體升級，windows 自動更新導致虛擬機完全壞掉的悲劇，總算不負苦心，有一個觀賞性較好的成果在最後的 Lab 展示上 Dos Lab 小結這個 Lab 給我留下許多虛擬機當掉搞心態的陰影，但這也給我關於虛擬機的開發經驗，讓我知道以後要怎麼處理這個棘手問題，希望明年也能再把這個很酷的 Lab 在展示出來，讓更多人知道 Dos 的暴力美學? 研討會研討會的話，其實沒什麼特別的，但還是說一下，這次身為機動組和餐飲組，老實說，自己從工作人員的角度反而沒有從會眾的角度來的精彩(可能因為規模比較小，加上自己不是核心人員)，但我自己覺得也不要過多的自我檢討，就當作見證黑客社十周年的一份子，提醒自己不要讓黑客社蒙羞 總結2023 年過了，接下來就是準備換我們接手黑客社了，希望透過這次的資安週、研討會經驗，能讓我們順利的將黑客精神傳承下去。最後放上 2023 的資安週團照","link":"/2024/01/12/HCCCON%20&%202023%20FCU%20%E8%B3%87%E5%AE%89%E9%80%B1%E6%84%9F%E6%83%B3/"},{"title":"Blog 工具打造：自動摺疊目錄","text":"前言：這篇文章是我記錄改編 Blog 的過程。我以 Hugo 上 Clean White Blog 的風格作為樣板， 在此之上增加更多有趣的互動功能，同時增進自己在前端開發的能力。 生成快速連結 首先需要定位我們要尋找的範圍 1var P = $(文本範圍的 selector) 接著在這個範圍找出我們要的 tag ，也就是 h1~h6 1a = P.find('h1,h2,h3,h4,h5,h6'); 將這些 tag 元素的資訊重組成快速連結並加入清單中 12345678a.each(function () { n = $(this).prop('tagName').toLowerCase(); i = &quot;#&quot; + $(this).prop('id'); t = $(this).text(); c = $(`&lt;a aria-label=&quot;${t}&quot; href=&quot;${i}&quot; rel=&quot;nofollow&quot;&gt;${t}&lt;/a&gt;`); l = $(`&lt;li class=&quot;${n}_nav&quot;&gt;&lt;/li&gt;`).append(c); $(selector).append(l);}) 完整的生成函式 12345678910111213141516171819202122function generateCatalog(selector) { _containerSelector = 'div.post-container' // 文本範圍 // init var P = $(_containerSelector), a, n, t, l, i, c; a = P.find('h1,h2,h3,h4,h5,h6'); // clean $(selector).html('') // 預防裡面有其他元素 // appending a.each(function () { n = $(this).prop('tagName').toLowerCase(); i = &quot;#&quot; + $(this).prop('id'); t = $(this).text(); c = $(`&lt;a aria-label=&quot;${t}&quot; href=&quot;${i}&quot; rel=&quot;nofollow&quot;&gt;${t}&lt;/a&gt;`); l = $(`&lt;li class=&quot;${n}_nav&quot;&gt;&lt;/li&gt;`).append(c); $(selector).append(l); }) return a;} 整理所有連結的資訊要整理的資訊我們總共需要 六 種資訊： 快速連結中的標題元素 標題層級下的所有子標題元素 第一個子標題元素 子標題數量 文章中標題位置 文章中的 tag 樣式 在這邊我是將上面的 a 抓來當作 sideElements，因為 a 裡面每個元素的 id 可以用來定位文本範圍內所要的標題元素，而 innerText 可以用來定位快速連結上的元素。也就是說，我用 id 來定位文本內的標題位置，用 innerText 來定位快速連結的位置。 在這邊子標題數量先預設為 0 ，等等會提到如何計算該層級下的子標題數量。還有對於「標題層級下的所有子標題元素」的作法我是用範圍搜索，也就是查詢直到跟我同層級的標題出現，但這樣會有一個問題，就是差很多層級的子標題也會納入，而這個問題等一下也會說明 12345678910111213141516171819sideElements.each((index, element) =&gt; { const name = element.id const innerTagsCount = 0 // 子標題數量預設為 0 const sideElement = $(`[aria-label=&quot;${element.innerText}&quot;]`) // 快速連結中的標題元素 const top = $(`[id=&quot;${name}&quot;]`).offset().top // 文章中標題位置 const htag = sideElement.parent() const innerTags = htag.nextUntil(`[class=&quot;${htag[0].className}&quot;]`) // 標題層級下的所有子標題元素 //第一個子標題元素 let innerFirstTag = null, i = 0 while(!innerFirstTag &amp;&amp; i &lt; innerTags.length){ if(innerTags[i].className &gt; htag[0].className) innerFirstTag = innerTags[i].className i++ } const tagName = $(`[id=&quot;${name}&quot;]`).prop(&quot;tagName&quot;) // 文章中的 `tag` 樣式 all_htags.push({ sideElement, innerTags, innerFirstTag, innerTagsCount, top, tagName })}) 隱藏所有子標題我先宣告 firstTag 記錄整篇文章第一個吃到的標題當作最上層級，而其他標題的層級如果與最上層級不同就隱藏。但這麼做的前提是最主要的標題前面沒有任何子標題，不然子標題會變成你的最上層級而導致結構矛盾(我是覺得這樣架構長的蠻奇怪的啦~ 12if(!firstTag) firstTag = tagNameif(tagName !== firstTag) sideElement.hide() 紀錄每個層級的數量接著宣告一個陣列用來儲存 h1~h6 的數量，但是這個紀錄實際上是記錄標題本身加上其子標題數量，而非真的每個層級的個別數量。在這裡我打算從後面算回來，也比較好去計算子標題的數量 1234567891011let count = [0, 0, 0, 0, 0]for(let i = all_htags.length - 1; i &gt;= 0; i--){ const index = parseInt(all_htags[i].tagName.slice(-1)) all_htags[i].innerTagsCount = 1 // 先加上自己 count[index - 1] += 1 // 將對應的層級加入 for(let j = index; j &lt; 5; j++){ // 將其所有子層級總和 all_htags[i].innerTagsCount += count[j] count[index - 1] += count[j] count[j] = 0 }} 以下面例子為例，右邊的數字為其所得出的子標題數量 1234567h1 6- h2 4-- h3 1-- h3 1-- h3 1- h2 1- h2 1 監聽滾動觸發效果我們總共需要兩種效果 換色：滾動到哪，哪個快速連結就顯示青色，反之就是灰色 摺疊：滾動到哪，就自動打開那層級下的子標題，反之，將其闔上 換色sideElement 代表的是快速連結的元素 12sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) // 顯示青色sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) // 移除顏色 摺疊innerTags 代表的是子標題群組，但由於我們是透過範圍抓取的，所以會將更為次等的子標題也抓進來，所以我們要篩選出差一個層級的子標題，而不是差兩個層級的子標題或差更多層級的子標題 12innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideDown() // 向下展開innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideDown() // 向上摺疊 掛上滾動監聽我們還需要當前滾動的位置與是不是已經滾到底部，不然如果已經滾到底部了，但快速連結的狀態卻不是最後一個就會很奇怪，通常這會出現在最後內容太短的情況 123let curPos = window.pageYOffset // 當前位置let isBottom = parseInt(curPos + document.documentElement.clientHeight) === document.documentElement.scrollHeight// 是否到達底部 最後條件判斷一下，是不是有子標題，有就加上摺疊效果和著色效果，沒有就只上著色效果。並且特判最後一個標題，避免內容太短的狀況滾動監聽完整程式碼 12345678910111213141516171819202122232425$(window).scroll(() =&gt; { let curPos = window.pageYOffset let isBottom = parseInt(curPos + document.documentElement.clientHeight) === document.documentElement.scrollHeight all_htags.forEach((item, index) =&gt; { const {sideElement, innerTags, innerFirstTag, innerTagsCount, top} = item if(index &lt; all_htags.length - 1){ // 是否為最後一個標題 if(innerTagsCount &gt; 1){ // 是否有子標題 if(curPos &gt;= top &amp;&amp; curPos &lt; all_htags[index + innerTagsCount].top &amp;&amp; !isBottom){ sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) // 上色 innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideDown() // 展開 } else{ sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) // 除色 innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideUp() // 摺疊 } }else{ if(curPos &gt;= top &amp;&amp; curPos &lt; all_htags[index + innerTagsCount].top &amp;&amp; !isBottom) sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) // 上色 else sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) // 除色 } }else{ // 最後一個標題 if(curPos &gt;= top || isBottom) sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) // 上色 else sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) // 除色 } })}) 完整程式碼12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function generateCatalog(selector) { _containerSelector = 'div.post-container' // init var P = $(_containerSelector), a, n, t, l, i, c; a = P.find('h1,h2,h3,h4,h5,h6'); // clean $(selector).html('') // appending a.each(function () { n = $(this).prop('tagName').toLowerCase(); i = &quot;#&quot; + $(this).prop('id'); t = $(this).text(); c = $(`&lt;a aria-label=&quot;${t}&quot; href=&quot;${i}&quot; rel=&quot;nofollow&quot;&gt;${t}&lt;/a&gt;`); l = $(`&lt;li class=&quot;${n}_nav&quot;&gt;&lt;/li&gt;`).append(c); $(selector).append(l); }) return a;}const sideElements = generateCatalog(&quot;.catalog-body&quot;), all_htags = []let firstTag = nullsideElements.each((index, element) =&gt; { const name = element.id const innerTagsCount = 0 const sideElement = $(`[aria-label=&quot;${element.innerText}&quot;]`) const top = $(`[id=&quot;${name}&quot;]`).offset().top const htag = sideElement.parent() const innerTags = htag.nextUntil(`[class=&quot;${htag[0].className}&quot;]`) let innerFirstTag = null, i = 0 while(!innerFirstTag &amp;&amp; i &lt; innerTags.length){ if(innerTags[i].className &gt; htag[0].className) innerFirstTag = innerTags[i].className i++ } const tagName = $(`[id=&quot;${name}&quot;]`).prop(&quot;tagName&quot;) if(!firstTag) firstTag = tagName if(tagName !== firstTag) sideElement.hide() all_htags.push({ sideElement, innerTags, innerFirstTag, innerTagsCount, top, tagName })})let count = [0, 0, 0, 0, 0]for(let i = all_htags.length - 1; i &gt;= 0; i--){ const index = parseInt(all_htags[i].tagName.slice(-1)) all_htags[i].innerTagsCount = 1 count[index - 1] += 1 if(i !== all_htags.length - 1 &amp;&amp; index !== 5){ for(let j = index; j &lt; 5; j++){ all_htags[i].innerTagsCount += count[j] count[index - 1] += count[j] count[j] = 0 } }}$(window).scroll(() =&gt; { let curPos = window.pageYOffset let isBottom = parseInt(curPos + document.documentElement.clientHeight) === document.documentElement.scrollHeight all_htags.forEach((item, index) =&gt; { const {sideElement, innerTags, innerFirstTag, innerTagsCount, top} = item if(index &lt; all_htags.length - 1){ if(innerTagsCount &gt; 1){ if(curPos &gt;= top &amp;&amp; curPos &lt; all_htags[index + innerTagsCount].top &amp;&amp; !isBottom){ sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideDown() } else{ sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) innerTags.filter((index, tag) =&gt; tag.className === innerFirstTag).slideUp() } }else{ if(curPos &gt;= top &amp;&amp; curPos &lt; all_htags[index + innerTagsCount].top &amp;&amp; !isBottom) sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) else sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) } }else{ if(curPos &gt;= top || isBottom) sideElement.attr(&quot;style&quot;, &quot;color: #337ab7&quot;) else sideElement.removeAttr(&quot;style&quot;, &quot;color&quot;) } })})","link":"/2023/08/27/Blog%20%E5%B7%A5%E5%85%B7%E6%89%93%E9%80%A0%EF%BC%9A%E8%87%AA%E5%8B%95%E6%91%BA%E7%96%8A%E7%9B%AE%E9%8C%84/"},{"title":"[Discord Bot] Commands Compare: Normal、Slash、Hybrid","text":"前言本文適合對 OOP 有略知，且已邀請機器人至伺服器的讀者。 若還未完成，這是我推薦的設置教程：Discord Bot 如果都沒問題就可以開始了~以下為本次測試的 Discord Bot 初始化設定 1234567891011121314151617181920212223242526import osimport discordfrom discord.ext import commandsfrom discord import app_commandsfrom dotenv import load_dotenvdef main(): # 建立一個機器人物件 client = commands.Bot( command_prefix = &quot;$&quot;, intents = discord.Intents.all() ) # 機器人事件 @client.event async def on_ready(): await client.change_presence(activity=discord.Game(name = &quot;coding For Fun&quot;)) logging_channel = await client.fetch_channel(os.getenv(&quot;LOGGING_CHANNEL&quot;)) await logging_channel.send(f&quot;Bot ready&quot;) # 執行機器人 client.run(os.getenv('BOT_TOKEN'))if __name__ == '__main__': load_dotenv() main() 首先用 discord.py 的 commands.Bot 建立一個機器人實體，並定義指令前綴（command prefix）和機器人權限 接著設定機器人事件，如果機器人準備好了，就在機器人所處的頻道打印 Bot ready 最後是執行機器人，我們會需要這台機器人的 Token，我是將 Token 放在 .env，透過 python_dotenv 這個套件提取至 os 的環境變數內 當設定好後，就可以玩各種指令啦，基本上 discord.py 的套件提供三種指令類型：Normal Command、Slash Command、Hybrid Command，接下來將會逐個介紹 Normal Command這種指令藉由指令前綴（command prefix）來呼叫，也就是要先打指令前綴讓機器人知道你在呼叫他 Build A Normal Command我們只需要使用 @client.command() 就能生成這種指令，而在此之下的函式就是這個指令要做的事情。ctx 代表 Context 物件，可以理解成是機器人的對話框。以這個指令為例，當使用者打出 $hello，機器人就會傳送 hello!!。 123@client.command(name=&quot;hello&quot;, description=&quot;Say Hello&quot;)async def hello(ctx): await ctx.send(&quot;hello!!&quot;) 而我們可以在 @client.command() 給予一些參數設定，例如：name，指令名稱（如果沒有提供，就會以該函數名稱代替）。以下為一些常見的參數設定： 12345678910@client.command( aliases=[&quot;hello&quot;], name=&quot;greeting&quot;, description=&quot;Hello Everyone&quot;, brief=&quot;This is greeting command&quot;, enabled=True, hidden=True)async def greeting(ctx): await ctx.send(&quot;hello!!&quot;) aliases（別名）：提供該指令其他呼叫名稱 description（說明）：描述該指令作用 help：在 help 資訊欄，詳述該指令作用 brief（簡述）：在 help 資訊欄，簡述該指令作用 enabled：當 True 時，該指令能被呼叫，反之不行 hidden：當 True 時，該指令不會顯示在 help 資訊欄 Commands Group如果我們有多個功能類似的 Normal Command，我們可以將其歸納成群組。 藉由 @client.group 我們可以決定這個群組名稱，同時這個群組可以單獨被視為一個指令，因此也會有呼叫這個指令時應該執行的函式。接者我們可以根據群組名去衍生更多的子指令，用法與 Normal Command 一樣。 1234567891011@client.group(name=&quot;greeting&quot;)async def greeting(ctx): await ctx.send(&quot;This is greeting Command&quot;)@greeting.command(name=&quot;hello&quot;)async def hello(ctx): await ctx.send(&quot;HELLO!!&quot;)@greeting.command(name=&quot;hi&quot;)async def hi(ctx): await ctx.send(&quot;HI!!&quot;) 這種 Commands Group 可以層層相套，也就是群組裡面的子指令也可以是一個群組，用來為指令分類很好用的 Slash Command這種指令可以直接用 / 呼叫，並且會在使用者介面上提供指令提示。但不能用自定義的指令前綴呼叫 Build A Slash Commanddiscord.py 在 版本 2.0 時於機器人底下新增一個 tree 屬性，解釋如下： The command tree responsible for handling the application commands in this bot. 在 discord.py API 提到 tree 是一種 CommandTree 類型的物件，裡面主要存放 application commands，而 Slash Command 就是數屬於這種，因此我們要做的是想辦法將自定義的 Slash Command 加入這個 CommandTree 物件 建立方法與 Normal Command 類似，用 @client.tree.command()來定義，與 Normal Command 不同的是，下面定義的函式第一個參數會是 interaction（互動物件），我們可以透過這樣的寫法來讓機器人發送訊息 123@client.tree.command(name = &quot;hello&quot;)async def first_command(interaction): await interaction.response.send_message(&quot;Hello!&quot;) Slash Commands Group如果有多個功能類似的 Slash Commands，我們也可以將其歸類成群組，這時會需要用到 app_commands.Group 這個類別。 我們可以定義一個 app_commands.Group，並將相關的 Slash 子指令 放入，要注意將原本是機器人的部分要改成 app_commands，讓這個指令單純只是 Slash Command。 1234567891011121314class Math_(app_commands.Group): @app_commands.command() async def add(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} + {two} = {one + two}&quot;) @app_commands.command() async def subtract(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} - {two} = {one - two}&quot;) @app_commands.command() async def multiple(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} x {two} = {one * two}&quot;) @app_commands.command() async def division(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} / {two} = {one / two}&quot;) 最後實體化這個 app_commands.Group 物件，並將其加入機器人的指令庫中 12math_ = Math_(name=&quot;math_&quot;)client.tree.add_command(math_) 完整程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142import discordfrom discord.ext import commandsfrom discord import app_commandsclass Math_(app_commands.Group): @app_commands.command() async def add(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} + {two} = {one + two}&quot;) @app_commands.command() async def subtract(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} - {two} = {one - two}&quot;) @app_commands.command() async def multiple(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} x {two} = {one * two}&quot;) @app_commands.command() async def division(self, interaction, one: int, two: int): await interaction.response.send_message(f&quot;{one} / {two} = {one / two}&quot;)def main(): intents = discord.Intents.all() client = commands.Bot( command_prefix=&quot;$&quot;, intents=intents ) @client.event async def on_ready(): client.tree.copy_global_to(guild=settings.GUILD_ID) await client.tree.sync(guild=settings.GUILD_ID) math_ = Math_(name=&quot;math_&quot;) client.tree.add_command(math_) await client.change_presence(activity=discord.Game(name = &quot;coding For Fun&quot;)) logging_channel = await client.fetch_channel(os.getenv(&quot;LOGGING_CHANNEL&quot;)) await logging_channel.send(f&quot;Bot ready&quot;) client.run(settings.BOT_TOKEN, root_logger=True)if __name__ == '__main__': main() CommandTree Sync當我們建立完成 Slash Command 並加入 CommandTree 後，會發現 Discord 上這個指令沒有作用，這是因為 discord 沒有接收 API 的請求將我們的 slash command 複製過去。 所以這時會需要用到 CommandTree.sync() 的這個方法，才會將當前的 Slash Command 同步複製一份給 discord。但是這個方法有個瑕疵，就是新增 Slash Command 時有速度限制，導致開發者有時候會誤入這個 Slash Command 沒有即時更新的陷阱。 於是 discord.py 提供了 CommandTree.copy_global_to() 先將當前的 CommandTree 複製一份給 discord，藉此優化後續的同步速度 1234@client.eventasync def on_ready(): client.tree.copy_global_to(guild=settings.GUILD_ID) slashTree = await client.tree.sync(guild = discord.Object(id = os.getenv('GUILD_ID'))) 關於這個問題有一篇完整的 github gist 說明：discord.py 2.0+ slash command info and examples. Hybrid Command這種指令可以同時被指令前綴和 / 呼叫，所以如同字面上意思，即兼具 Slash Command 和 Normal Command 的呼叫特性。注意該命令也需要 CommandTree.sync() 同步。 Build A Hybrid Command定義 @client.hybrid_command() 就能使用這種指令，函式內的第一個參數是 ctx（Context 物件） 1234567@client.hybrid_command( name = &quot;hello&quot;, description = &quot;My first application Command&quot;, guild = discord.Object(id = os.getenv('GUILD_ID')) )async def first_command(ctx): await ctx.send(&quot;Hello!&quot;) Hybrid Commands Group與 Normal Commands Group 寫法差不多，如下 12345678910@client.hybrid_group()async def test(ctx): await ctx.send(&quot;Test!!&quot;)@test.command(name=&quot;hi&quot;)async def hi(ctx): await ctx.send(&quot;HI!!&quot;)@test.command(name=&quot;hey&quot;)async def hey(ctx): await ctx.send(&quot;HEY!!&quot;) 延伸：在 Cog 中使用這些指令在 discord.py 中，對 Cog 的定義是這樣： A cog is a collection of commands, listeners, and optional state to help group commands together 與 Commands Group 相比之下這個集合具有監聽、事件處理的額外功能，也就是說 Cog 可以當成是一個更強大的指令集合，此外藉由這個方式定義的指令在 help 資訊欄中會標記其集合名稱，讓其可讀性更好。 與在主程式的寫法很像，只是要把原本機器人的部分（client）改掉就可以，記住參數裡的第一個參數是 self（這與類別有關，但非這次討論重點）。最後要補上 setup 函式，讓這個 cog 類別能被初始化 12345678910111213141516171819202122232425class cmds(commands.Cog): def __init__(self, client): self.client = client @commands.Cog.listener() async def on_ready(self): print(f'{__name__} loaded successfully!') # normal command @commands.command(name=&quot;hello&quot;, description=&quot;Say Hello&quot;) async def command(self, ctx): await ctx.send(&quot;HELLO!!&quot;) # slash command @app_commands.command(name=&quot;happy&quot;, description=&quot;Say Happy Happy&quot;) async def command(self, interaction: discord.Interaction): await interaction.response.send_message(&quot;Happy! Happy! Happy~&quot;) # hybrid command @commands.hybrid_command(name=&quot;hi&quot;, description=&quot;Say Hi&quot;) async def command(self, ctx): await ctx.send(&quot;HI!!&quot;)async def setup(client): await client.add_cog(cmds(client)) 至於要怎麼在主程式呼叫這個類別，只要在 on_ready 的函式下加入這條就可以了，注意檔案名稱的後綴（.py）要拿掉 1await client.load_extension(&quot;你的 Cog 檔案名稱&quot;) 小結 Normal Command 是最基礎的指令，藉由指令前綴的方式呼叫，可以將多個 Normal Command 集合成 Commands Group，分類出子指令來使用 Slash Command 於 discord.py 版本 2 中加入，可以透過 / 方式呼叫，讓使用者不需要呼叫 help 資訊欄，就能知道哪些指令可以使用，是一種較為新型的寫法，可以透過 app_command.Group 類別將 Slash Commands 集合成群組 Hybrid Command 兼具 Slash 和 Normal 的呼叫方式 與 Command Group 相比，我會更偏向使用 Cog 作為分類依據，接著再使用 Commands Group 做更精細的分類 參考資料 discord.py API Reference How to create a DISCORD BOT (2023 with discordpy 2 in python)","link":"/2023/07/06/%5BDiscord%20Bot%5D%20Commands%20Compare%20Normal%20Slash%20Hybrid/"},{"title":"整合 Discord Slash 指令與 Notion，自動化集中碎片資源","text":"前言我經常把 discord server 當作自己的筆記本去接收各種新知識，但也就僅止於一個 Link，提醒我有這麼個酷東西，需要的時候再翻來看看，但我想要對這些碎片資源快速做個 overview，並記錄起來，但這樣全部塞在同一個 channel 會導致資料雜亂，剛好最近實驗室告訴我有 n8n 這樣子的自動化工作流工具，可以快速幫我搭建一個收集工作流，將 discord 上面的資料全部儲存進 notion，以後需要找資源時，就不用在 discord 上翻找，可以從資料庫一目瞭然，而且要對這些資源做額外的延伸，就只需要在新頁面繼續紀錄就好，整體更有系統性。 架設流程架設 n8n 和申請一個 discord bot我使用 Zeabur 部署 n8n，當然也可以在自己的 VM 上部屬，但這部分可能要等到我需要集中式管理我的 IT 資產時才有這麼個打算，所以現在就先使用第三方平台幫我快速部屬 n8n，部屬方式如下： 這邊先選取 GCP 的 Free Trial，但只有 24hr 的使用，目前對於我這樣實驗性質的使用不影響，但如果要長期使用的話，建議選擇 AWS Tokyo/Japan，主要是距離最近，傳輸速度會快些，但要另外每個月付 5 美元，其實沒有很多啦。 接著搜尋 n8n，然後點擊最多下載量的 service 就可以了 成功建立 n8n 後，點擊網路並找到網域的欄位，可以使用自訂網域，也可以直接使用 Zeabur 提供的網域，輸入後點擊網址就可以進到 n8n 的工作介面了 另外還要申請一支 discord bot ，這部分網路資源很多，這邊就不多作介紹 為 discord bot 配置 interaction endpoint以下是 n8n 的 workflow，會對主要邏輯作說明，細項設定請參考最後的設定 json 首先需要監聽 discord bot 接收到的指令，所以 n8n 開頭的節點為 webhook，點擊設置，先將 Test URL 的 Request 改成 POST 並將這個 URL 貼到 discord bot 的 Interactions Endpoint URL，到此會發現測試會失敗是正常的，因為我們沒有回覆這個 verify。如果要成功設置，根據 discord develop 需要達成兩點 成功確認並回傳 PONG 給來自 Discord 的 PING requests 驗證 security-related request headers (X-Signature-Ed25519 and X-Signature-Timestamp) 首先來處理第一點，進入第二個節點，我們要將 request 整理成要用來驗證的資料，也就是（X-Signature-Ed25519 and X-Signature-Timestamp），還有 discord bot 的 publicKey 接著使用一個社群開發的 node 來實現驗證，要引入這個 node 的路徑：Settings &gt; Community nodes &gt; Install &gt; 輸入 n8n-nodes-tweetnacl 經過驗證後會給一欄位（isVerified）表示是否成功驗證，所以要作 if 判斷，成功就回傳 {&quot;type&quot;: 1}，失敗就回傳 reponse code 401。 最後這份 interaction endpoint 的 workflow 如下，可以直接引入到 n8n 使用 使用 postman 註冊 slash command成功將 endpoint 加入 disocrd bot 之後就可以來自定義指令了，我們可以使用 postman 向 discord api 註冊一個 slash command 到我們的 discord bot。根據 postman doc 提供的設置，我們只需要修改 application id、body 和 authorization header。 application id 應該不用解釋，就是 discord bot 的 application id，而 body 我們可以簡化成這樣就好 123456789101112131415161718{ &quot;name&quot;: &quot;link&quot;, &quot;description&quot;: &quot;Add link to Notion&quot;, &quot;options&quot;: [ { &quot;name&quot;: &quot;title&quot;, &quot;description&quot;: &quot;Add the Title you want to Notion&quot;, &quot;required&quot;: true, &quot;type&quot;: 3 }, { &quot;name&quot;: &quot;url&quot;, &quot;description&quot;: &quot;Add the URL you want to Notion&quot;, &quot;required&quot;: true, &quot;type&quot;: 3 } ]} 最後的 authorization header 要另外添加到 headers，value 為 BOT [Bot Token]，雖然 postman 有提供 authorization 的功能，但不知道為甚麼沒有用，所以只好以 header 方式發送就能成功註冊，送出後有回覆 200 或 201 的 response code 就是註冊成功，如果 discord 的指令沒有提示，可以將 bot 踢出後重新邀請試試。 接收 slash command 並寫入 notion回到 n8n 完成工作流，如下 我們可以透過 request body 中的 type 來分析是哪種類型的 event，如果 type = 1，就是 PING EVENT，也就是前段的 endpoint 驗證，否則就是我們的 slash command event，所以先用 if 來判斷 {{ $json.body.type }} 接著我們要將 data 寫入 notion，需要使用到 notion node，這次使用 create database page，我想要將收集到的資源都作成一個 page 存進各自的 database。但在這之前需要先去 notion 開通一個 Integrations，路徑如下：Settings &gt; My connections &gt; Develop or manage integrations。 使用 internal Integration Secret，只讓處於同個 workspace 的使用這可以使用，最後將這段 secret 寫入 n8n 的 notion 節點的 Credential to connect with 欄位，Database 欄位選擇 By ID，並將 database 的 ID 寫入。 補充一點 notion 的 database id 是這樣看的：https://www.notion.so/&lt;long_hash_1&gt;?v=&lt;long_hash_2&gt;，前者是 database id，後者是 view id。資料來源 還有最重要的一點，就是要將 notion database 作 connection 設定，這樣才找得到 database，才能 fetch 出需要的 key property 完整的 notion node 設置如下 進到最後的節點，也就是完成之後要將回傳訊息給 discord，設置 {&quot;data&quot;:{&quot;content&quot;: &quot;&quot;}}，用來當作 discord bot 回覆的內容，還有記得要設置一個 {&quot;type&quot;: 4}，來說明此 slash command event 成功完成。 完整的 workflow，包含設定細項如下 轉換成生產環境所有測試完成之後，就是轉換成生產環境啦，打開 Active 就可以了，記得 production URL 與 test URL 不一樣，所以要進到 webook 裡面複製替換掉 discrod bot 的 interaction endpoint。 總結這樣就快速建立一個 workflow，幫助我們抓取 discord bot 的訊息並記錄到 notion 的 database，之後會想要結合爬蟲與 AI 來快速分析文章內容，完善這整套系統，將 notion 的知識庫發揮更高價值。 資料來源 Zeabur deploy n8n connect your Notion workspace with Slash Command via n8n Discord Interactions Endpoint URL validation","link":"/2025/01/23/n8n-%E6%95%B4%E5%90%88%20Discord%20Slash%20%E6%8C%87%E4%BB%A4%E8%88%87%20Notion/"},{"title":"[ GIT 錯誤報告 ]","text":"錯誤紀錄遠端儲存庫沒有對應的分支12error: src refspec main does not match any error: failed to push some refs to [repo_url] 解決方法將本地儲存庫待上傳的分支更名 1git branch -m [old branch] [new branch] 部分內容未被合併，該版本不是遠端儲存庫最新版本12! [rejected] main -&gt; main (non-fast-forward) error: failed to push some refs to [repo_url] 解決方法先拉取遠端儲存庫分支版本，並將其允許無相關的歷史紀錄與現在分支合併接著重新提交 1234git fetch origin maingit merge --allow-unrelated-histories origin/main git add . git commit .gitignore 沒有效果原因：因為 git 通常會去讀取緩存的那份 .gitignore，而這份通常指的是該項目在遠端儲存庫當前的版本，所以才會無論怎麼對 .gitignore 操作都無法改變。 解決方法先清除掉 local 端的 git 緩存，重新創建一份 .gitignore 後，再將此版本提交上主線程 1234git rm -r --cached .git add .git commit -m 'update .gitignore'# 記得不要使用 git commit -a -m 或是 git commit . -m 的指令樣式，不然會將之前的內容也新增回來 這樣處理完後，如果有其他人 clone 此專案，只需執行前兩步即可 個人建立的私有資料庫無法上傳問題原因：私有資料庫只允許擁有者和被邀請加入的開發者才能上傳、下拉使用，所以需要表示上傳者的身分才能成功上傳 解決方法總共有兩種方式解決，第一種較適合還沒 clone repo，第二種則適合已經 clone 但不想重新 clone 的開發者 將 repo 以 ssh 方式 clone 創建 personal access token 並以這樣的形式（https://[your-username]:[your-private-access-token-here]@github.com/[your-repo]）加入 remote url git clone Error：”RPC failed”、”POST of ‘XXX’ failed”使用 git clone 出現以下問題 12345error: RPC failed; curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8)error: 5492 bytes of body are still expectedfetch-pack: unexpected disconnect while reading sideband packetfatal: early EOFfatal: fetch-pack: invalid index-pack output 這是因為要 clone 的 repo 太大，導致無罰成功拉取 解決方法 第一種方法是減少拉取提交的次數，例如使用 depth 參數指定只拉取近幾次的提交。 1git clone https://github.com/XXX/XXX.git --depth 1 題外話，如果要拉取所有的歷史版本，可以用 unshallow 參數 1git fetch --unshallow 第二種方法就是變更設定的緩存空間 12git config --global http.postBuffer &lt;大小&gt;# 如果要更改為 5 MB，就是設成 5M 如上面的問題顯示，http.postBuffer 的預設值是 1MB，因此 5492 bytes 無法拉取，所以我們要把 buffer 改超過 5MB 才可以順利拉取這份資料。 此外這個參數設定只影響透過 http 協議拉取 repo，如果用 SSH、或其他協議則不受此影響。 參考資料 Fatal: refusing to merge unrelated histories Rejected problem git-repository-not-found-error-for-private-repository-on-github git-clone-error","link":"/2022/09/28/%5B%20GIT%20%E9%8C%AF%E8%AA%A4%E5%A0%B1%E5%91%8A%20%5D/"},{"title":"談談 Docker 環境變數","text":"前言由於現在開發很依賴 Docker，所以在面臨不同環境時，需要設置並管理一大堆環境變數，所以希望藉由這片紀錄整理出在 Docker 如何使用環境變數來實現想要的環境效果，主要會從 .env 最常見的設置手法開始說明，接者進入 Dockerfile 講解 ARG、ENV 的使用，來靈活設置不同 stage 的情況以及如果想要額外測試不同的環境變數，可以怎麼透過 Docker CLI 或修改 docker-compose 的方式來作調適，最後探討如果有敏感資料要怎麼安全的處理。 以下為本次實作的 Application 為 flask 簡單建立的 Web Application app.py12345678910111213141516from flask import Flaskfrom dotenv import load_dotenvimport osload_dotenv()app = Flask(__name__)@app.route('/')def home(): user = os.getenv('user', 'Flask') more = os.getenv('more', 'This is a simple Flask app running in a localhost.') return f&quot;Hello, {user}! {more}&quot;if __name__ == '__main__': app.run(host=&quot;0.0.0.0&quot;, debug=True) .env通常 .env 會用來跟 docker-compose 結合作為動態變數使用，以 Dollar-notation variables 的形式取出 .env 指定的變數，如下這樣就可以取出 user 環境變數和 more 環境變數 .env12user=Dockermore=This is a simple Flask app running in a Docker container. docker-compose.yml12345678910version: '3'services: flask: build: . environment: - user=${user} - more=${more} ports: - &quot;8080:5000&quot; 可以使用 docker-compose config，來協助 debug 環境變數替換後的 compose 檔案 docker-compose config123456789101112131415161718192021$ docker-compose configWARN[0000] /mnt/c/Users/marve/Project/Personal/2025-02-11/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion name: &quot;2025-02-11&quot;services: flask: build: context: /mnt/c/Users/marve/Project/Personal/2025-02-11 dockerfile: Dockerfile environment: more: This is a simple Flask app running in a Docker container. user: Docker networks: default: null ports: - mode: ingress target: 5000 published: &quot;8080&quot; protocol: tcpnetworks: default: name: 2025-02-11_default 而經過 docker-compsoe 建立出來的 image 當中的環境變數也就變成了 docker-compose config 檢視後的樣子，所以用這樣的 image 所建立出來的 container 預設就會使用如同 .env 的環境變數。 但是 .env 定義的環境變數卻很容易被其他方式覆蓋，例如在 build image 階段我啟動 docker-compose 時定義環境變數，就可以取代掉原本的環境變數 在 build image 替換環境變數123$ user=&quot;shell&quot; more=&quot;This is running by shell&quot; docker-compose up -d# 在網頁上會顯示 Hello, shell! This is running by shell 又或著我在建立新的 container 就可以透過 -e 來取代掉原本的環境變數 在 create container 替換環境變數123$ docker run -d -p 8081:5000 -e &quot;user=test&quot; -e &quot;more=this is test&quot; --name test 2025-02-11-flask# 在網頁上會顯示 Hello, test! this is test 除了使用 .env 搭配 docker-compose 作為動態變數的方式，也可以改成從 Dockerfile 下手，所以接下來談談 Dockerfile 中 ARG 和 ENV 的使用 ARG 和 ENV 的使用ARG 和 ENV 最主要的差別在於有效的範圍 ARG：只在 build image 階段有效 ENV：在 build image 和 running contaienr 階段都有效 how to use ARG被 ARG 定義出來的變數稱為 build-time variables，只有在 build 階段有效，也就是只限於 Dockerfile 使用，常見使用方式如下，另外也可透過 --build-arg 的參數在 build 階段覆蓋 Dockefile 預設，至於 docker-compose，則是使用 args 來加入。 dockerfile12ARG ENV=productionRUN if [ &quot;$ENV&quot; = &quot;development&quot; ]; then npm install --dev; else npm install; fi docker-compose.yml123456789101112version: '3'services: flask: build: . environment: - user=${user} - more=${more} ports: - &quot;8080:5000&quot; args: some_variable_name: a_value 而也因為只存在 build 階段，所以不適合出現在 CMD、ENTRYPOINT，這樣在 running container 階段會因為抓取不到變數而報錯。除此之外，也不建議將敏感資料放在 ARG，因為還是有可能在 image history、build cache 洩漏。 how to use ENV通常會需要沿用到 running container 的環境變數就會透過 ENV 來設定，在 Dockerfile 的寫法如下 dockerfile123# ENV 需要有預設值，Dockerfile 接受以下兩種寫法ENV VERSION 1.0 ENV VERSION=2.0 至於如果想要在 build 階段可以設置動態的 ENV values，則可以搭配 ARG 使用，如下 dockerfile12ARG VERSION_ARGENV VERSION=$VERSION_ARG 而經過 build 階段還是有其他方式在 running container 時可以覆蓋 image 原有的環境變數，以下提供三種方式 透過 -e 逐個變數覆蓋，這樣的效果在前面的 .env 示範過就不說明了，而這等同於在 docker-compose.yml 設定 environment docker-compose.yml1234567version: '3'services: flask: build: . environment: - env_var=some_val 透過參考 Host Machine 的環境變數 參考 Host Machine 的環境變數12345678$ export more=&quot;this is host env&quot;$ env | grep moremore=this is host env# 開啟一個 test image 建立的 container，叫做 test2$ docker run -e more -d -p 8082:5000 --name test2 test$ curl localhost:8082Hello, Docker! this is host env 從 env_file 獲取環境變數 從 env_file 獲取環境變數123$ docker run --env-file=env_file -d -p 8003:5000 --name test3 test$ curl localhost:8003Hello, ENV_FILE! Running With ENV_FILE. docker-compose.yml123456789version: '3'services: flask: build: . env_file: - env_file ports: - &quot;8080:5000&quot; 另外如果想要透過 Dockerfile 指令的方式，如：RUN export user=123，會發現這個變數沒辦法在下一行被調用，這是因為這個變數不會被保留，所以不要異想天開，這和 ENV 設置環境變數的方式不一樣。 另外關於 docker-compose 取得環境變數的順位如下 Compose file Shell environment variables environment attribute in compose file Environment file passed to compose env_file attribute in compose file .env file Dockerfile Secert 問題儘管已經刪除了關於環境變數的檔案，但如果在 build image 時將 secert（如：SSH key）透過 ARG 方式帶入，還是有可能透過 docker history IMAGE_ID 被查找出來，所以不是很建議透過 build-time variables 來傳遞 secert，以下為 ARG 傳遞變數，可以從 image history 洩漏： 1234567$ docker build --build-arg DEFAULT_MESSAGE=hello -t test2 .$ docker history c37f01ea78e4c37f01ea78e4 29 seconds ago CMD [&quot;python&quot; &quot;app.py&quot;] 0B buildkit.dockerfile.v0&lt;missing&gt; 29 seconds ago RUN |1 DEFAULT_MESSAGE=hello /bin/sh -c pip … 10.8MB buildkit.dockerfile.v0&lt;missing&gt; 37 seconds ago RUN |1 DEFAULT_MESSAGE=hello /bin/sh -c echo… 0B buildkit.dockerfile.v0&lt;missing&gt; 38 seconds ago EXPOSE map[5000/tcp:{}] 0B buildkit.dockerfile.v0&lt;missing&gt; 38 seconds ago COPY . /app # buildkit 19.2MB buildkit.dockerfile.v0 至於要怎麼傳遞 secert，以下提供幾種方法： Squashing --squash 可以協助 build image 時移除之後完全不需要的檔案來減少 image 大小，並且減少原來到最新階段 image 之間的層級，這樣就可以有效移除 secert 檔案在 image 的痕跡 --squash1$ docker build --squash [...] 但同樣的這樣會減少 Docker layer caching 的使用，另外如果某次忘記 squashing，則有更高的風險外洩。 Multi-stage Builds更好的方式是使用多階段的 build，先將 secert 用於中間層級的 image 來存取需要 secert 的資料並將這些資料傳遞到最後 image 建置的過程，這樣就能避免 secert 洩漏。以下是參考資料的範例 Multi-stage Dockerfile12345678910111213141516171819202122# this is our first build stage, it will not persist in the final imageFROM ubuntu as intermediate# install gitRUN apt-get updateRUN apt-get install -y git# add credentials on buildARG SSH_PRIVATE_KEYRUN mkdir /root/.ssh/RUN echo &quot;${SSH_PRIVATE_KEY}&quot; &gt; /root/.ssh/id_rsa# make sure your domain is acceptedRUN touch /root/.ssh/known_hostsRUN ssh-keyscan bitbucket.org &gt;&gt; /root/.ssh/known_hostsRUN git clone git@bitbucket.org:your-user/your-repo.gitFROM ubuntu# copy the repository form the previous imageCOPY --from=intermediate /your-repo /srv/your-repo# ... actually use the repo :) 先透過 SSH_PRIVATE_KEY 取出 private github repo，最後將這個 repo 的位置複製進最後 image，這樣就能完美避開 SSH_PRIVATE_KEY 出現在 history command 當中 總結以下為這次的重點 .env 與 docker-compose 的交互 ARG 與 ENV 的差別 如何在 build image 階段覆蓋 ARG 如何在 running container 階段覆蓋原有的環境變數 如何查看 docker-compose 的環境變數設定 docker-compose 抓取環境變數的順序 如何避免 secert 於 image history 洩漏 經過這次學習，可以更靈活的調適不同環境，也可以更有效的 debug，甚至如何避免 secert 洩漏，希望能幫助大家在 docker 環境下更有效的開發。 資料來源 docker-arg-env-variable-guide override-docker-compose-dot-env build-docker-image-clone-private-repo-ssh-key","link":"/2025/02/11/%E8%AB%87%E8%AB%87-Docker-%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/"},{"title":"[Discord Bot] Better Interactions with UI","text":"Discord UI 使用Discord.ext 提供許多 UI 元件來優化使用者體驗，而不需要以純文字、接收數個參數等繁雜處理方式來獲得我們所需要的資訊。以下將說明如何使用 Discord UI 元件。 首先，大部分網路上的作法都是將需要用到的 UI 元件逐個加入到一個 discord.ui.View 的 class 當中，所以需要先創建一個 discord.ui.View 的 class 123class MyView(discord.ui.View): def __init__(self): super().__init__() 當把所有 UI 元件加入至這個 class 之後，將此作為 discord.ext.commands.Context 中 view 屬性的對應值，就能成功發送至 Discord 聊天室。記得要在 MyView 後面加上 () 表示是由 MyView 這個 class 所生成出來的物件，如果不知道為什麼，請先去看 OOP。 123@client.hybrid_command() async def test(ctx: commands.Context): await ctx.send(content=&quot;This is Test.&quot;, view=MyView()) 那麼要怎麼將 UI 元件加入這個 class 當中?首先要知道部分 UI 元件有分為 shortcut decorator 的用法和 class/object 的用法，注意他們在名稱上可能只有大小寫的差別，所以要清楚當前使用的 UI 元件要以什麼形式加入 class 當中，才能順利的組合出想要的 UI 互動 方法一：使用 UI 元件的 Class我們可以使用 discord.ui.View 中的 add_item 方法來加入類別形式的 UI 元件，如下： 1234class MyView(discord.ui.View): def __init__(self): super().__init__() self.add_item(...) # 加入需要的 UI 元件 以 Button UI 作為範例，如下： 1234class MyView(discord.ui.View): def __init__(self): super().__init__() self.add_item(discord.ui.Button(label=&quot;Click Me!&quot;, style=discord.ButtonStyle.link, url=&quot;https://www.google.com/&quot;)) 方法二：使用 shortcut decorator 的方式建立 UI 元件以 shortcut decorator 的方式建立 UI 元件，會需要建立一個同步回傳函式，用來處理該 UI 被觸發的後續動作。因此用這種方式建立的 UI 元件的變化性更高，只是不能像類別形式的 UI 元件一樣寫成 One Line Code 的形式。 1234567class MyView(discord.ui.View): def __init__(self): super().__init__() @discord.ui.button(label=&quot;Click Primary!&quot;, style=discord.ButtonStyle.link) async def button_callback1(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button!&quot;) 你可以發現在 Button UI 元件的不同實現上，分別是 discord.ui.button 和 discord.ui.Button，說明大小寫是會影響程式的，因此在搭配更複雜的元件組合時要小心這些細節 各種 UI 元件的詳細使用方式接下來，將對 Button、DropDown(Select Menu) 和 Dialog 做詳細的實作說明 Button之前的範例有提到如何實現一個按鈕，這邊就簡單的做個說明如何實現一顆按鈕 1234567class MyView(discord.ui.View): # 創建一個 ui 事件的 class def __init__(self): super().__init__() @discord.ui.button(label=&quot;Click me!&quot;) # 使用 discord.ui.button 來創建按鈕 async def button_callback(self, interaction, button): # 當按鈕被觸發時所做出的回應 await interaction.response.send_message(&quot;You clicked the button!&quot;) 實現多顆按鈕如果要用多顆按鈕可以參考以下寫法： 123456789101112class MyView(discord.ui.View): def __init__(self): super().__init__() self.add_item(discord.ui.Button(label=&quot;Click Me TO YT!&quot;, url=&quot;https://www.youtube.com/&quot;)) self.add_item(discord.ui.Button(label=&quot;Click Me TO Google!&quot;, url=&quot;https://www.google.com/&quot;)) @discord.ui.button(label=&quot;Click 1!&quot;) async def button_callback1(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button 1!&quot;) @discord.ui.button(label=&quot;Click 2!&quot;) async def button_callback2(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button 2!&quot;) 更多按鈕樣式若要為按鈕添加更多樣式，可以添加 style 屬性，如下：更多樣式的按鈕 12345678910111213141516class MyView(discord.ui.View): def __init__(self): super().__init__() @discord.ui.button(label=&quot;Click Primary!&quot;, style=discord.ButtonStyle.primary) async def button_callback1(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button!&quot;) @discord.ui.button(label=&quot;Click Success!&quot;, style=discord.ButtonStyle.success) async def button_callback2(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button!&quot;) @discord.ui.button(label=&quot;Click Danger!&quot;, style=discord.ButtonStyle.danger) async def button_callback3(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button!&quot;) @discord.ui.button(label=&quot;Click Secondary!&quot;, style=discord.ButtonStyle.secondary) async def button_callback5(self, interaction, button): await interaction.response.send_message(&quot;You clicked the button!&quot;) 導向外部網站如果要導向外部網站，要簡單的話，使用類別形式（discord.ui.Button）來實現即可，因為只有這個類別才提供 url 屬性，不然就是要自己再寫其他導向的方法在回傳函式當中 1234class MyView(discord.ui.View): def __init__(self): super().__init__() self.add_item(discord.ui.Button(label=&quot;Click Me!&quot;, style=discord.ButtonStyle.link, url=&quot;https://www.google.com/&quot;)) 更多的使用方法可以參考 Discord Button UI DropDownsDropDowns(Select Menu) 提供下拉式選單的互動方式，讓使用者在多個選擇的情況下，有更良好的體驗，以下是實現一個 DropDowns(Select Menu) 的簡單作法： 123456789101112_list = [&quot;Coffee&quot;, &quot;Soda&quot;, &quot;Tea&quot;, &quot;Lemonade&quot;, &quot;Mike&quot;] def __init__(self): super().__init__() @discord.ui.select( placeholder = &quot;選擇你喜歡的飲料&quot;, min_values = 1, max_values = 3, options = [discord.SelectOption(label = data) for data in _list], ) async def callback(self, interaction, select): await interaction.response.send_message(f&quot;You choose {' '.join([data for data in select.values])}!!&quot;) 這是使用 shortcut decorator 的 discord.ui.select 來實現 DropDown 的方法，可以透過 select 接收到所選取的選項。 但如果是要用類別形式的 DropDown 來實現，就需要先覆寫其 callback 方法，並呼叫 interaction.data 屬性才能取得所選取的選項，如下： 12345678910_list = [&quot;Coffee&quot;, &quot;Soda&quot;, &quot;Tea&quot;, &quot;Lemonade&quot;, &quot;Mike&quot;]class MyView(discord.ui.View): def __init__(self): super().__init__() self.add_item(MySelect(options=[discord.SelectOption(label = data) for data in _list], min_values=1, max_values=3))class MySelect(discord.ui.Select): async def callback(self, interaction): await interaction.response.send_message(f&quot;You choose {' '.join([data for data in interaction.data['values']])}!!&quot;) discord 的內建選單discord 的內建選單，諸如： 該伺服器的使用者清單（User Select） 該伺服器的身分組清單（Role Select） 該伺服器地提及清單（Mention Select） 該伺服器的頻道清單等（Channel Select） 這裡的實作方式與官方的 Document 上的方法大為不同（因為不知道為什麼明明版本沒問題，但就是找不到官方的屬性）。如果對官方的寫法有興趣可以查詢 shortcut decorator 中關於 discord.ui.user_select 的作法，如果有成功做出來，那應該會比這裡所寫的還簡單很多，到此為止，來看看我如何實現 discord 的內建選單（以 User Select 做示範）： 一樣創建一個 discord.ui.View 的 class，並把新定義的 discord.ui.UserSelect 放入當中 接著在新定義的 discord.ui.UserSelect 中，繼承原有的屬性，並加入新的屬性（client） 覆寫 callback 方法，獲取 interaction.data['value']，這一個陣列所儲存的是被選中的 user id 如果要透過 user id 轉為其他 user 資訊的話，就需要用到剛剛所加入的 client 屬性，這是一個 commands.Bot 物件，可以透過 get_user 解析 user id 來獲取 user 完整資訊 記得要將 discord Bot 丟入新開的 client 屬性 12345678910111213141516class MyView(discord.ui.View): def __init__(self, client): super().__init__() self.add_item(MySelect(min_values=1, max_values=3, client=client))class MySelect(discord.ui.UserSelect): def __init__(self, client: commands.Bot, min_values: int = 1, max_values: int = 1): super().__init__(min_values=min_values, max_values=max_values) self.client = client self.selectUser = [] async def callback(self, interaction): for id in interaction.data['values']: user = self.client.get_user(int(id)) self.selectUser.append(user.name) await interaction.response.send_message(f&quot;You choose {' '.join(self.selectUser)}&quot;) 123@client.hybrid_command() async def test(ctx: commands.Context): await ctx.send(content=&quot;This is Test.&quot;, view=MyView(client=client)) 這些內建清單回傳的 interaction.data['values'] 全部都是 id，若需要近一步完整資訊可參考上面 User Select 透過 discord bot 解析 id 的方法 其他內建選單 1234567891011class RoleSelect(discord.ui.RoleSelect): async def callback(self, interaction): await interaction.response.send_message(f&quot;You choose {' '.join(interaction.data['values'])}&quot;)class MentionableSelect(discord.ui.MentionableSelect): async def callback(self, interaction): await interaction.response.send_message(f&quot;You choose {' '.join(interaction.data['values'])}&quot;)class ChannelSelect(discord.ui.ChannelSelect): async def callback(self, interaction): await interaction.response.send_message(f&quot;You choose {' '.join(interaction.data['values'])}&quot;) Dialogdiscord.ui.Model 類別實現這類元件，效果是彈出視窗的表單填寫。 以下是簡單實現一個表單的功能，目前只能使用 discord.ui.TextInput 123456789class MyModal(discord.ui.Modal): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) name = discord.ui.TextInput(label=&quot;Short Input&quot;) descrpition = discord.ui.TextInput(label=&quot;Long Input&quot;, style=discord.TextStyle.long, max_length=100) async def on_submit(self, interaction: discord.Interaction): await interaction.response.send_message(f&quot;Hello {self.name}! {self.descrpition}&quot;) 當然也可以用 add_item 的方式將 discord.ui.TextInput 加入，但取出方式就需要用到 self.children 12345678class MyModal(discord.ui.Modal): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.add_item(discord.ui.TextInput(label=&quot;Short Input&quot;)) self.add_item(discord.ui.TextInput(label=&quot;Long Input&quot;, style=discord.TextStyle.long, max_length=100)) async def on_submit(self, interaction: discord.Interaction): await interaction.response.send_message(f&quot;Hello {self.children[0].value}! {self.children[1].value}&quot;) 接下來有個關鍵的重點，我們雖然已經設定好 model 了，但不能當作 view 傳給 contest，而是要藉由 UI 元件傳遞，雖然也可以使用 slash commands 來傳遞，但還是覺得用 UI 元件傳遞比較適合 12345678class MyView(discord.ui.View): def __init__(self): super().__init__() @discord.ui.button(label=&quot;Send Modal&quot;) async def button_callback(self, interaction: discord.Interaction, button): await interaction.response.send_modal(MyModal(title=&quot;Modal via Button&quot;)) # 透過 button 的 interaction 傳遞 modal 資料來源 discord.py API Reference","link":"/2023/08/28/%5BDiscord%20Bot%5D%20Better%20Interactions%20with%20UI/"},{"title":"嘗試優化網頁直到 LightHouse 放煙火","text":"本篇的動機為某次 Web 上課的作業是優化 Free CSS 網站上提供的模板，以 Lighthouse 的評測結果作為評分標準。當時以前端起家的我想說，那豈不是輕輕鬆鬆，但在第一個項目 Performance 的優化上，才發現沒這麼簡單，比如：要壓縮 JS 文檔需要打包工具，也就是 webpack、vite 這類的前端打包工具。轉念一想，自己好像沒有深入研究過打包工具，所以這篇主要會拆分成兩部分，有使用與未使用打包工具來各個擊破 Lighthouse 提供的問題點。 另外為什麼我選擇 webpack，因為 Free CSS 的模板主要以 CommonJS 實現模組功能，這樣就不需要特別設定 ESModule，另外也因為其發展較久，所以網路上的資源相當豐富，學習起來應該不會太難吧，另外在結合 react.js 和 babel，形成 react.js + webpack + babel 的三件套。 Performance這一部分基本上只要 webpack 配置的好，就能處理大部分的問題。左邊為原本的模板結構，右邊為修改後的結構。 12345678910111213141516171819202122D:.│ 404.html│ about.html│ booking.html│ contact.html│ destination.html│ index.html│ package.html│ service.html│ team.html│ testimonial.html│├─css├─img├─js└─lib ├─animate ├─easing ├─owlcarousel ├─tempusdominus ├─waypoints └─wow 123456789101112131415161718192021D:.|├─dist├─node_modules├─public| ├─404.html| ├─favicon.ico| └─index.html|├─src| ├─assets| ├─components| ├─css| ├─js| ├─App.jsx| └─index.js|├─.babelrc├─package-lock.json├─package.json└─webpack.config.js 一般屬性output：用來設定打包後輸出的位置 path：打包後輸出的位置 filename：打包後的名稱 而這邊 name 就會根據 key 值去生成 123456module.exports = { output: { path: __dirname + &quot;/dist&quot;, filename: &quot;[name].js&quot;, },} devServer：用來設置開發時的測試環境 static：靜態檔案來源 compress：是否需要壓縮檔案 port：開啟的埠口 1234567module.exports = { devServer: { static: path.resolve(__dirname, &quot;dist&quot;), compress: true, port: 9000, },} resolve：這個設定用來描述 module 如何被解析 alias：可以用來替換使用 import 方法的路徑，假如有一個路徑：import 'src/css/style.css'，就可以透過下面配置換成 import 'css/style.css' 1234567module.exports = { resolve: { alias: { css: path.resolve(__dirname, &quot;src/css&quot;) }, }} entry：抓取 js 的進入點，如下圖所示，會將這些進入點，也就是會使用到的 js 全部打包成 bundle.js 12345678module.exports = { entry: { bundle: [ &quot;./src/js/main.js&quot;, ... ], }} Module 配置 css 先透過 css-loader 處理，接者用 MiniCssExtractPlugin 插件壓縮。 配置 js、jsx 則使用 babel-loader 加載處理，babel 可以處理不同 js 版本的問題 打包圖片的部分，webpack 5 之前是採用 file-loader 或 url-loader 處理圖片，而我這次使用的是 webpack 5，這是用 type:asset 方式配置 1234567891011121314151617181920212223242526272829303132module.exports = { module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], }, { test: /\\.(js|jsx)/, exclude: /node_modules/, use: { loader: &quot;babel-loader&quot;, options: { presets: ['@babel/preset-react', '@babel/preset-env'], }, }, }, { test: /\\.(png|jpe?g|gif|webp)$/i, type: 'asset', parser: { dataUrlCondition: { maxSize: 10 * 1024, // 小於 10 KB 會轉成 base64 的 url } }, generator:{ filename:'static/images/[name][ext]', // 輸出檔案位置 }, }, ], }} Plugin HtmlWebpackPlugin：用來壓縮 html MiniCssExtractPlugin： 用來壓縮 css BundleAnalyzerPlugin：檔案打包後的可視化工具 123456789101112module.exports = { plugins: [ new HtmlWebpackPlugin({ template: './public/index.html', filename: 'index.html', inject: true, minify: true, }), new MiniCssExtractPlugin(), new BundleAnalyzerPlugin() ],} Optiminization這一部分配置打包優化的設定，主要介紹兩個常用的配置，TerserPlugin 插件和 splitChunks，最終配置如下 123456789101112131415161718192021module.exports = { optimization: { splitChunks: { cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, chunks: 'initial', name: 'vendors', enforce: true, priority: 10, // 預設為 0，必須大於預設 cacheGroups }, } }, minimize: true, minimizer: [ new TerserPlugin({ test: /\\.js(\\?.*)?$/i, }) ], }} TerserPlugin用來壓縮 js 檔案，安裝指令與使用方式如下 1npm install terser-webpack-plugin --save-dev 12345678910module.exports = { optimization: { minimize: true, minimizer: [ new TerserPlugin({ test: /\\.js(\\?.*)?$/i, }) ], }} splitChunkssplitChunks 可以幫助我們拆分 js 檔案，減少單個 bundle 的容量，比如 node_modules 的第三方模組打包成 vendor.js，自己開發的 js 模組打包成 bundle.js，而這項設定在 webpack4 就被預設開啟，所以不需要另外下載，以下為 splitChunks 的預設配置 123456789101112131415161718192021splitChunks: { chunks: 'async', minSize: 30000, // minRemainingSize: 0, (Webpack 5 才有此選項) maxSize: 0, minChunks: 1, maxAsyncRequests: 6, maxInitialRequests: 4, automaticNameDelimiter: '~', cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, }, },} 最重要的是 chunks 和 cacheGroups 的設定，其他設定基本上就是字面的意思 chunks：async | initial | all async：只處理 lazy loading 的 chunk，如：import(xxx) 語法載入的模組 initial：只處理同步加載的 chunk，如：import xxx 語法載入的模組 all：處理以上兩種情況的 chunk cacheGroups 定義 chunks 所屬的緩存組 {cacheGroups}：緩存組名稱，可由 name 屬性更改 cacheGroups.{cacheGroups}.priority：緩存組優先級，默認為 0 cacheGroups.{cacheGroups}.test：控制當下緩存組匹配的 chunk，省略它會選擇所有 chunk cacheGroups.{cacheGroups}.filename：僅當 chunk 為同步加載時，才允許覆蓋文件名 cacheGroups.{cacheGroups}.enforce：忽略全域的部分選項 補充 1：可以將 caheGroups 當作一個區域，所以當我們在這個區域內配置的 chunks 屬性就不會影響到其他 cacheGroups，也就是說 cacheGroups 彼此的設定是獨立的 補充 2：如果想要避免全域設定的 chunks 影響到 cacheGroups 的設定，可以添加 enforce 為 true，這樣就會強制使用 cacheGroups 內的設定 AccessibillityElements must meet minimum color contrast ratio thresholds 這條的問題點希望我們能縮小顏色對比的閥值，使得使用者能更好的閱讀 APP 上的文字。 標準如下： 小型文字 =&gt; 4.5:1 大型文字 =&gt; 3:1 可以透過這個網頁工具來調出適合的閥值 Links must have discernible text 這條問題點可以添加 aria-label 屬性來對 link 加以敘述 更多關於這個問題的詳細說明 Best PracticeUses third-party cookies 這條問題點避免使用第三方 cookies 解決方法：由於我的第三方 cookies 是來自於 font-awesome 來載入 icon 圖檔，所以我可以將圖檔下載後，以靜態檔案的方式加入。 其他方法： 添加 Cookie 屬性 Partitioned，以支援依頂層環境劃分的跨網站 Cookie 使用相關網站集（RWS），說明網站間的關係，使瀏覽器能允許第三方 cookie 更多關於這個問題的詳細說明 總結 使用 webpack + react.js + babel 優化 Performance 使用到的 webpack 設定如下 mode、devtool、entry、resolve.alias、output、devServer module.rules 使用 MiniCssExtractPlugin、css-loader 加載 css 使用 babel-loader 加載 js 使用 webpack5 的內建方式(type: ‘asset’)打包圖片 plugins HtmlWebpackPlugin MiniCssExtractPlugin BundleAnalyzerPlugin：可視化分析 bundle optimization splitChunks chunks、cacheGroups TerserPlugin 使用線上工具調整顏色閥值 Links element 要添加 aria-label 表敘述 避免使用第三方 cookies 最後附上一張 Lighthouse 的煙火 相關資料 webpack documations webpack-splitchunks webpack5-react-ts web-dev remove-duplicate-modules-in-javascript-bundles Web Vitals 優化方式懶人包","link":"/2024/04/25/%E5%98%97%E8%A9%A6%E5%84%AA%E5%8C%96%E7%B6%B2%E9%A0%81%E7%9B%B4%E5%88%B0%20LightHouse%20%E6%94%BE%E7%85%99%E7%81%AB/"},{"title":"掃描紀錄自動轉化工具","text":"大綱主要紀錄一下這兩點的開發過程，而這個案子雖然還用到了爬蟲抓取中文翻譯的資料，並且使用了 pandas 來實現 xlsx 的轉換，但因為沒什麼特別的地方，都是很基礎的語法功能而已，這邊就不紀錄了。 讀取 .nessus 檔案（解析 XML 的過程） Command Line 功能（python argparse module 的使用） 讀取 .nessus 檔案使用第三方函示庫 nessus_file_reader，來讀取 .nessus 檔案。使用到的程式碼如下 1234567import nessus_file_reader as nfrroot = nfr.file.nessus_scan_file_root_element(filename) # 讀入檔案for case_index, report_host in enumerate(nfr.scan.report_hosts(root)): report_items_per_host = nfr.host.report_items(report_host) for index, report_item in enumerate(report_items_per_host): __risk_factor = nfr.plugin.report_item_value(report_item, 'risk_factor') __plugin_id = nfr.plugin.report_item_value(report_item, 'pluginID') 這個套件的解析過程會把 .nessus 當作 XML 來分析，先找出這份 XML 的 root 之後，尋找所有的 ReportHost，這是每一組 ip 的報告結果，接者再從這些報告結果中找出 ReportItem 一筆一筆分析 了解 nessus_file_reader 是如何解析 XML，就換我用 ElementTree 寫一個。 1234567891011121314151617import xml.etree.ElementTree as ETfilename = &quot;&quot;def main(): tree = ET.parse(filename) root = tree.getroot() # 找出 XML 檔案的 root hosts = root.find(&quot;Report&quot;).findall(&quot;ReportHost&quot;) # 找出所有的 ReportHost report_item_name = &quot;risk_factor&quot; for report_host in hosts: reports = report_host.findall(&quot;ReportItem&quot;) # 從每個 ReportHost 找出所有的 ReportItem for report_item in reports: report_item_content_value = report_item.get(report_item_name) if report_item_content_value is None: report_item_content = report_item.find(report_item_name) if report_item_content is not None: report_item_content_value = report_item_content.text 需要注意的是，在找 report_item_name 的 tag，可能會遇到多層的巢狀結構，所以如果用 get() 的返回值為 None，也就是 tag 的 attribute 沒有 report_item_name，此時就需要用 find() 往內尋找 自訂義 Command Line這是我第一次挑戰寫 CLI 的工具，直接使用內建的 argparse 來建立指令，一開始需要先宣告 parser 1parser = argparse.ArgumentParser(description='CLI描述') 設置預設觸發 function1parser.set_defaults(handle=simple_transform) 參數功能設置如下，其中 store_true 代表只要出現這個參數就設為 True，這樣就不用特地給將 True Value 打出來 123456parser.add_argument('-sl', '--show_all_level', action='store_true', help='是否輸出 Critical level 之外等級的漏洞')parser.add_argument('-info', '--info', action='store_true', help='是否輸出 infomation')parser.add_argument('-o', '--output', type=str, default=os.getcwd(), help='輸出的位置') 群組功能這個功能可以用來設置一定要輸入該群組中其中一個指令 12345group = parser.add_mutually_exclusive_group(required=True)group.add_argument('-f', '--file', type=str, help='要轉換的 .nessus 檔案')group.add_argument('-l', '--list', type=str, help='轉換多個 .nessus 檔案') 子命令功能如果要增加子命令，使用以下方法即可，subparsers 的用法就跟 parser 一樣 1subparsers = parser.add_subparsers(metavar='子命令') 資料來源 nessus-file-reader Python Cli 編寫指南","link":"/2024/03/23/%E6%8E%83%E6%8F%8F%E7%B4%80%E9%8C%84%E8%87%AA%E5%8B%95%E5%8C%96%E8%BD%89%E5%8C%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"crawler","slug":"crawler","link":"/tags/crawler/"},{"name":"back-end","slug":"back-end","link":"/tags/back-end/"},{"name":"grist","slug":"grist","link":"/tags/grist/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"hugo","slug":"hugo","link":"/tags/hugo/"},{"name":"n8n","slug":"n8n","link":"/tags/n8n/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"react","slug":"react","link":"/tags/react/"}],"categories":[{"name":"DeveOps","slug":"DeveOps","link":"/categories/DeveOps/"},{"name":"Data Analysis","slug":"Data-Analysis","link":"/categories/Data-Analysis/"},{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"Develop","slug":"Develop","link":"/categories/Develop/"},{"name":"Version Control","slug":"DeveOps/Version-Control","link":"/categories/DeveOps/Version-Control/"},{"name":"System Arch","slug":"System-Arch","link":"/categories/System-Arch/"},{"name":"Socity","slug":"Socity","link":"/categories/Socity/"},{"name":"Forensics","slug":"Security/Forensics","link":"/categories/Security/Forensics/"},{"name":"Backend","slug":"Develop/Backend","link":"/categories/Develop/Backend/"},{"name":"Web","slug":"Develop/Web","link":"/categories/Develop/Web/"},{"name":"Chatbot","slug":"Develop/Chatbot","link":"/categories/Develop/Chatbot/"},{"name":"Workflow Tools","slug":"Workflow-Tools","link":"/categories/Workflow-Tools/"},{"name":"Docker","slug":"DeveOps/Docker","link":"/categories/DeveOps/Docker/"},{"name":"Tools","slug":"Develop/Tools","link":"/categories/Develop/Tools/"}],"pages":[]}